# 初探富文本之文档虚拟滚动
虚拟滚动是一种优化长列表性能的技术，其通过按需渲染列表项来提高浏览器运行效率。具体来说，虚拟滚动只渲染用户浏览器视口部分的文档数据，而不是整个文档结构，其核心实现根据可见区域高度和容器的滚动位置计算出需要渲染的列表项，同时不渲染额外的视图内容。虚拟滚动的优势在于可以大大减少`DOM`操作，从而降低渲染时间和内存占用，解决页面加载慢、卡顿等问题，改善用户体验。

## 描述
前段时间用户向我们反馈了一个问题，其产品有比较多的大型文档在我们的文档编辑器上进行编辑，但是因为其文档内容过长且有大量表格，导致在整个编辑的过程中卡顿感比较明显，而且在消费侧展示的时候需要渲染比较长的时间，用户体验不是很好。于是我找了一篇比较大的文档测试了一下，由于这篇文档实在是过大，首屏的`LCP`达到了`6896ms`，即使在各类资源有缓存的情况下`FCP`也需要`4777ms`，单独拎出来首屏的编辑器渲染时间都有`2505ms`，整个应用的`TTI`更是达到了`13343ms`，在模拟极限快速输入的情况下`FPS`仅仅能够保持在`5+`，`DOM`数量也达到了`24k+`，所以这个问题还是比较严重的，于是开始了漫长的调研与优化之路。

### 方案调研
在实际调研的过程中，我发现几乎没有关于在线文档编辑的性能优化方案文章，那么对于我来说几乎就是从零开始调研整个方案。当然社区还是有很多关于虚拟滚动的性能优化方案的，这对最终实现整个方案有很大的帮助。此外，我还在想把内容都放在一篇文档里这个行为到底是否合适，这跟我们把代码都写在一个文件里似乎没什么区别，总感觉组织形式上可能会有更好的方案，不过这就是另一个方向上的问题了，在这里我们还是先关注于大型文档的性能问题。

* 渐进式分页加载方案: 通过数据驱动的方式，我们可以渐进式获取分块的数据，无论是逐页请求还是`SSE`的方式都可以，然后逐步渲染到页面上，这样可以减少首屏渲染时间，紧接着在渲染的时候同样也可以根据当前实际显示的页来进行渲染，这样可以减少不必要的渲染从而提升性能。例如`Notion`就是完全由数据驱动的分页加载方式，当然数据还是逐步加载的，并没有实现按需加载数据，这里需要注意的是按需加载和按需渲染是两个概念。实际上这个方案非常看重文档本身的数据设计，如果是类似于`JSON`块嵌套的表达结构，实现类似的方案会比较简单一些，而如果是通过扁平的表达结构描述富文本，特别是又存在块嵌套概念的情况下，这种方式就相对难以实现。
* `Canvas`分页渲染方案: 现在很多在线文档编辑器都是通过`Canvas`来进行渲染的，例如`Google Docs`、腾讯文档等，这样可以减少`DOM`操作，`Canvas`的优势在于可以自定义渲染逻辑，可以实现很多复杂的渲染效果与排版效果，但是缺点也很明显，所有的东西都需要自行排版实现，这对于内容复杂的文档编辑器来说就变得没有那么灵活。实际上使用`Canvas`绘制文档很类似于`Word`的实现，初始化时按照页数与固定高度构建纯空白的占位结构，在用户滚动的时候才挂载分页的`Canvas`渲染视口区域固定范围的页内容，从而实现按需渲染。
* 行级虚拟滚动方案: 绝大部分基于`DOM`的在线文档编辑器都会存在行或者称为段落的概念，例如飞书文档、石墨文档、语雀等，或者说由于`DOM`本身的结构表达，将内容分为段落是最自然的方式，这样就可以实现行级虚拟滚动，即只渲染当前可见区域范围的行，这样可以减少不必要的渲染从来提升性能。通常我们都仅会在主文档的直属子元素即行元素上进行虚拟滚动，而对于嵌套结构例如行内存在的代码块中表达出的行内容则不会进行虚拟滚动，这样可以减少虚拟滚动的复杂度，同时也可以保证渲染的性能。
* 块级虚拟滚动方案，从`Notion`开始带动了文档编辑器`Block`化的趋势，这种方式可以更好的组织文档内容，同时也可以更好的实现文档的块结构复用与管理，那么此时我们基于行的表达同样也会是基于`Block`的表达，例如飞书文档同样也是采用这种方式组织内容。在这种情况下，我们同样可以基于行的概念实现块级虚拟滚动，即只渲染当前可见区域范围的块，实际上如果独立的块比较大的时候还是有可能影响性能，所以这里仍然存在优化空间，例如飞书文档就对代码块做了特殊处理，即使在嵌套的情况下仍然存在虚拟滚动。那么对于非`Blocks`表达的文档编辑器，块级虚拟滚动方案仍然是不错的选择，此时我们将虚拟滚动的粒度提升到块级，对于很多复杂的结构例如代码块、表格、流程图等块结构做虚拟滚动，同样可以有不错的性能提升。

### 虚拟滚动
在具体实现之前我思考了一个比较有意思的事情，为什么虚拟滚动能够优化性能。我们在浏览器中进行`DOM`操作的时候，此时这个`DOM`是真正存在的吗，或者说我们在`PC`上实现窗口管理的时候，这个窗口是真的存在的吗。那么答案实际上很明确，这些视图、窗口、`DOM`等等都是通过图形化模拟出来的，虽然我们可以通过系统或者浏览器提供的`API`来非常简单地实现各种操作，但是实际上些内容是系统帮我们绘制出来的图像，本质上还是通过外部输入设备产生各种事件信号，从而产生状态与行为模拟，诸如碰撞检测等等都是系统通过大量计算表现出的状态而已。

那么紧接着，在前段时间我想学习下`Canvas`的基本操作，于是我实现了一个非常基础的图形编辑器引擎。因为在浏览器的`Canvas`只提供了最基本的图形操作，没有那么方便的`DOM`操作从而所有的交互事件都需要通过鼠标与键盘事件自行模拟，这其中有一个非常重要的点是判断两个图形是否相交，从而决定是否需要按需重新绘制这个图形来提升性能。那么我们设想一下，最简单的判断方式就是遍历一遍所有图形，从而判断是否与即将要刷新的图形相交，那么这其中就可能涉及比较复杂的计算，而如果我们能够提前判断某些图形是不可能相交的话，就能够省去很多不必要的计算。那么在视口外的图层就是类似的情况，如果我们能够确定这个图形是视口外的，我们就不需要判断其相交性，而且本身其也不需要渲染，那么虚拟滚动也是一样，如果我们能够减少`DOM`的数量就能够减少很多计算，从而提升整个页面的运行时性能，至于首屏性能就自不必多说，减少了`DOM`数量首屏的绘制一定会变快。

当然上边只是我对于提升文档编辑时或者说运行时性能的思考，实际上关于虚拟滚动优化性能的点在社区上有很多讨论了。诸如减少`DOM`数量可以减少浏览器需要渲染和维持的`DOM`元素数量，进而内存占用也随之减少，这使得浏览器可以更快地响应用户操作。以及浏览器的`reflow`和重绘`repaint`操作通常是需要大量计算的，并且随着`DOM`元素的增多而变得更加频繁和复杂，通过虚拟滚动个减少需要管理的`DOM`数量，同样可显著提高渲染性能。此外虚拟滚动还有更快的首屏渲染时间，特别是大文档的全量渲染很容易导致首屏渲染时间过长，还能够减少`React`维护组件状态所带来的`Js`性能消耗，特别是在存在`Context`的情况下，不特别关注就可能会存在性能劣化问题。

那么在研究了虚拟滚动的优势之后，我们就可以开始研究虚拟滚动的实现了，在进入到富文本编辑器的块级虚拟滚动之前，我们可以先来研究一下虚拟滚动都是怎么做的。那么在这里我们以`ArcoDesign`的`List`组件为例来研究一下通用的虚拟滚动实现。在`Arco`给予的示例中我们可以看到其传递了`height`属性，此时如果我们将这个属性删除的话虚拟列表是无法正常启动的，那么实际上`Arco`就是通过列表元素的数量与每个元素的高度，从而计算出了整个容器的高度，这里要注意滚动容器实际上应该是虚拟列表的容器外的元素，而对于视口内的区域则可以通过`transform: translateY(Npx)`来做实际偏移，当我们滚动的时候，我们需要通过滚动条的实际滚动距离以及滚动容器的高度，配合我们配置的元素实际高度，就可以计算出来当前视口实际需要渲染的节点，而其他的节点并不实际渲染，从而实现虚拟滚动。当然实际上关于`Arco`虚拟列表的配置还有很多，在这里就不完整展开了。

```js
<List
  {/* ... */}
  virtualListProps={{
    height: 560,
  }}
  {/* ... */}
/>
```

通过简单分析`Arco`的通用列表虚拟滚动，我们可以发现实现虚拟滚动似乎并没有那么难，然而在我们的在线文档场景中，实现虚拟滚动可能并不是简单的事情。我们先来看一下在文档中图片渲染的实现，通常在上传图片的时候，我们会记录图片的大小也就是宽高信息，在实际渲染的时候会通过容器最大宽高以及`object-fit: contain;`来保证图片比例，当渲染时即使图片未实际加载完成，但是其高度占位是已经固定的。然而回到我们的文档结构中，我们的块高度是不固定的，特别是文本块的高度，在不同的字体、浏览器宽度等情况下表现是不同的，我们无法在其渲染之前的到其高度，这就导致了我们无法像图片一样提前计算出其占位高度，从而对于文档块结构的虚拟滚动就必须要解决块高度不固定的问题，由此我们需要实现相关管理策略来处理这个问题。

## 模块设计
实际上富文本编辑器的具体实现有很多种方式，基于`DOM`与`Canvas`绘制富文本的区别我们就不聊了，在这里我们还是关注于基于`DOM`的富文本编辑器上，例如`Quill`是完全自行实现的视图`DOM`绘制，而`Slate`是借助于`React`实现的视图层，这两者对于视图层的实现方式有很大的不同，在本文中是偏向于`Slate`的实现方式，也就是借助于`React`来构建块级别的虚拟滚动，当然实际上如果能够完全控制视图层的话，对于性能可优化的空间会更大，例如可以更方便地调度闲时渲染配合缓存等策略，从而更好地优化快速滚动时的体验。实际上无论是哪种方式，对于本文要讲的核心内容差距并没有那么大，只要我们能够保证富文本引擎本身控制的选区模块、高度计算模块、生命周期模块等正确调度，以及能够控制实际渲染行为，无论是哪种编辑器引擎都是可以应用虚拟滚动方案的。

### 滚动调度
IntersectionObserver OnScroll

### 块管理器
增删改查

### 状态管理
LayoutModule HOC 管理各个行/块状态 
事件触发

### 选区状态
选区Model映射
全选

### 视口锁定
overflow-anchor
scrollRestoration
Resize

### 快速滚动
快速滚动 与 闲时渲染

## 场景推演
单独实现虚拟滚动是不够的 必须要为虚拟滚动做`API`兼容

### 锚点跳转
锁视口 提前渲染

### 搜索替换
VirtualLayer现场渲染 不可替换内容 滚动动画调度

### 评论能力
更新评论位置 按需更新

## 性能考量
在我们兼容完成各类功能之后 必须要对这个需求进行性能考量 ROI

### 性能指标
LCP TTI

### 性能测试
块数量分级测试

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-anchor
https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver
https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry
https://developer.mozilla.org/zh-CN/docs/Web/API/History/scrollRestoration
https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
https://arco.design/react/components/list#%E6%97%A0%E9%99%90%E9%95%BF%E5%88%97%E8%A1%A8
```

