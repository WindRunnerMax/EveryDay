# 初探富文本之文档虚拟滚动
虚拟滚动是一种优化长列表性能的技术，其通过按需渲染列表项来提高浏览器运行效率。具体来说，虚拟滚动只渲染用户浏览器视口部分的文档数据，而不是整个文档结构，其核心实现根据可见区域高度和容器的滚动位置计算出需要渲染的列表项，同时不渲染额外的视图内容。虚拟滚动的优势在于可以大大减少`DOM`操作，从而降低渲染时间和内存占用，解决页面加载慢、卡顿等问题，改善用户体验。

## 描述
前段时间用户向我们反馈了一个问题，其产品有比较多的大型文档在我们的文档编辑器上进行编辑，但是因为其文档内容过长且有大量表格，导致在整个编辑的过程中卡顿感比较明显，而且在消费侧展示的时候需要渲染比较长的时间，用户体验不是很好。于是我找了一篇比较大的文档测试了一下，由于这篇文档实在是过大，首屏的`LCP`达到了`6896ms`，即使在各类资源有缓存的情况下`FCP`也需要`4777ms`，单独拎出来首屏的编辑器渲染时间都有`2505ms`，整个应用的`TTI`更是达到了`13343ms`，在模拟极限快速输入的情况下`FPS`仅仅能够保持在`5+`，`DOM`数量也达到了`24k+`，所以这个问题还是比较严重的，于是开始了漫长的调研与优化之路。

### 方案调研
在实际调研的过程中，我发现几乎没有关于在线文档编辑的性能优化方案文章，那么对于我来说几乎就是从零开始调研整个方案。当然社区还是有很多关于虚拟滚动的性能优化方案的，这对最终实现整个方案有很大的帮助。此外，我还在想把内容都放在一篇文档里这个行为到底是否合适，这跟我们把代码都写在一个文件里似乎没什么区别，总感觉组织形式上可能会有更好的方案，不过这就是另一个方向上的问题了，在这里我们还是先关注于大型文档的性能问题。

* 渐进式分页加载方案: 通过数据驱动的方式，我们可以渐进式获取分块的数据，无论是逐页请求还是`SSE`的方式都可以，然后逐步渲染到页面上，这样可以减少首屏渲染时间，紧接着在渲染的时候同样也可以根据当前实际显示的页来进行渲染，这样可以减少不必要的渲染从而提升性能。例如`Notion`就是完全由数据驱动的分页加载方式，当然数据还是逐步加载的，并没有实现按需加载数据，这里需要注意的是按需加载和按需渲染是两个概念。实际上这个方案非常看重文档本身的数据设计，如果是类似于`JSON`块嵌套的表达结构，实现类似的方案会比较简单一些，而如果是通过扁平的表达结构描述富文本，特别是又存在块嵌套概念的情况下，这种方式就相对难以实现。
* `Canvas`分页渲染方案: 现在很多在线文档编辑器都是通过`Canvas`来进行渲染的，例如`Google Docs`、腾讯文档等，这样可以减少`DOM`操作，`Canvas`的优势在于可以自定义渲染逻辑，可以实现很多复杂的渲染效果与排版效果，但是缺点也很明显，所有的东西都需要自行排版实现，这对于内容复杂的文档编辑器来说就变得没有那么灵活。实际上使用`Canvas`绘制文档很类似于`Word`的实现，初始化时按照页数与固定高度构建纯空白的占位结构，在用户滚动的时候才挂载分页的`Canvas`渲染视口区域固定范围的页内容，从而实现按需渲染。
* 行级虚拟滚动方案: 绝大部分基于`DOM`的在线文档编辑器都会存在行或者称为段落的概念，例如飞书文档、石墨文档、语雀等，或者说由于`DOM`本身的结构表达，将内容分为段落是最自然的方式，这样就可以实现行级虚拟滚动，即只渲染当前可见区域范围的行，这样可以减少不必要的渲染从来提升性能。通常我们都仅会在主文档的直属子元素即行元素上进行虚拟滚动，而对于嵌套结构例如行内存在的代码块中表达出的行内容则不会进行虚拟滚动，这样可以减少虚拟滚动的复杂度，同时也可以保证渲染的性能。
* 块级虚拟滚动方案，从`Notion`开始带动了文档编辑器`Block`化的趋势，这种方式可以更好的组织文档内容，同时也可以更好的实现文档的块结构复用与管理，那么此时我们基于行的表达同样也会是基于`Block`的表达，例如飞书文档同样也是采用这种方式组织内容。在这种情况下，我们同样可以基于行的概念实现块级虚拟滚动，即只渲染当前可见区域范围的块，实际上如果独立的块比较大的时候还是有可能影响性能，所以这里仍然存在优化空间，例如飞书文档就对代码块做了特殊处理，即使在嵌套的情况下仍然存在虚拟滚动。那么对于非`Blocks`表达的文档编辑器，块级虚拟滚动方案仍然是不错的选择，此时我们将虚拟滚动的粒度提升到块级，对于很多复杂的结构例如代码块、表格、流程图等块结构做虚拟滚动，同样可以有不错的性能提升。

### 虚拟滚动
在具体实现之前我思考了一个比较有意思的事情，为什么虚拟滚动能够优化性能。我们在浏览器中进行`DOM`操作的时候，此时这个`DOM`是真正存在的吗，或者说我们在`PC`上实现窗口管理的时候，这个窗口是真的存在的吗。那么答案实际上很明确，这些视图、窗口、`DOM`等等都是通过图形化模拟出来的，虽然我们可以通过系统或者浏览器提供的`API`来非常简单地实现各种操作，但是实际上些内容是系统帮我们绘制出来的图像，本质上还是通过外部输入设备产生各种事件信号，从而产生状态与行为模拟，诸如碰撞检测等等都是系统通过大量计算表现出的状态而已。

那么紧接着，在前段时间我想学习下`Canvas`的基本操作，于是我实现了一个非常基础的图形编辑器引擎。因为在浏览器的`Canvas`只提供了最基本的图形操作，没有那么方便的`DOM`操作从而所有的交互事件都需要通过鼠标与键盘事件自行模拟，这其中有一个非常重要的点是判断两个图形是否相交，从而决定是否需要按需重新绘制这个图形来提升性能。那么我们设想一下，最简单的判断方式就是遍历一遍所有图形，从而判断是否与即将要刷新的图形相交，那么这其中就可能涉及比较复杂的计算，而如果我们能够提前判断某些图形是不可能相交的话，就能够省去很多不必要的计算。那么在视口外的图层就是类似的情况，如果我们能够确定这个图形是视口外的，我们就不需要判断其相交性，而且本身其也不需要渲染，那么虚拟滚动也是一样，如果我们能够减少`DOM`的数量就能够减少很多计算，从而提升整个页面的运行时性能，至于首屏性能就自不必多说，减少了`DOM`数量首屏的绘制一定会变快。

当然上边只是我对于提升文档编辑时或者说运行时性能的思考，实际上关于虚拟滚动优化性能的点在社区上有很多讨论了。诸如减少`DOM`数量可以减少浏览器需要渲染和维持的`DOM`元素数量，进而内存占用也随之减少，这使得浏览器可以更快地响应用户操作。以及浏览器的`reflow`和重绘`repaint`操作通常是需要大量计算的，并且随着`DOM`元素的增多而变得更加频繁和复杂，通过虚拟滚动个减少需要管理的`DOM`数量，同样可显著提高渲染性能。此外虚拟滚动还有更快的首屏渲染时间，特别是大文档的全量渲染很容易导致首屏渲染时间过长，还能够减少`React`维护组件状态所带来的`Js`性能消耗，特别是在存在`Context`的情况下，不特别关注就可能会存在性能劣化问题。

那么在研究了虚拟滚动的优势之后，我们就可以开始研究虚拟滚动的实现了，在进入到富文本编辑器的块级虚拟滚动之前，我们可以先来研究一下虚拟滚动都是怎么做的。那么在这里我们以`ArcoDesign`的`List`组件为例来研究一下通用的虚拟滚动实现。在`Arco`给予的示例中我们可以看到其传递了`height`属性，此时如果我们将这个属性删除的话虚拟列表是无法正常启动的，那么实际上`Arco`就是通过列表元素的数量与每个元素的高度，从而计算出了整个容器的高度，这里要注意滚动容器实际上应该是虚拟列表的容器外的元素，而对于视口内的区域则可以通过`transform: translateY(Npx)`来做实际偏移，当我们滚动的时候，我们需要通过滚动条的实际滚动距离以及滚动容器的高度，配合我们配置的元素实际高度，就可以计算出来当前视口实际需要渲染的节点，而其他的节点并不实际渲染，从而实现虚拟滚动。当然实际上关于`Arco`虚拟列表的配置还有很多，在这里就不完整展开了。

```js
<List
  {/* ... */}
  virtualListProps={{
    height: 560,
  }}
  {/* ... */}
/>
```

通过简单分析`Arco`的通用列表虚拟滚动，我们可以发现实现虚拟滚动似乎并没有那么难，然而在我们的在线文档场景中，实现虚拟滚动可能并不是简单的事情。此处我们先来设一下在文档中图片渲染的实现，通常在上传图片的时候，我们会记录图片的大小也就是宽高信息，在实际渲染的时候会通过容器最大宽高以及`object-fit: contain;`来保证图片比例，当渲染时即使图片未实际加载完成，但是其高度占位是已经固定的。然而回到我们的文档结构中，我们的块高度是不固定的，特别是文本块的高度，在不同的字体、浏览器宽度等情况下表现是不同的，我们无法在其渲染之前得到其高度，这就导致了我们无法像图片一样提前计算出其占位高度，从而对于文档块结构的虚拟滚动就必须要解决块高度不固定的问题，由此我们需要实现动态高度的虚拟滚动调度策略来处理这个场景。而实际上如果仅仅是动态高度的虚拟滚动也并不是特别困难，社区已经有大量的实现方案，但是我们的文档编辑器是有很多复杂的模块在内的，例如选区模块、评论功能、锚点跳转等等，要兼容这些模块便是在文档本体虚拟滚动之外需要关注的功能实现。

## 模块设计
实际上富文本编辑器的具体实现有很多种方式，基于`DOM`与`Canvas`绘制富文本的区别我们就不聊了，在这里我们还是关注于基于`DOM`的富文本编辑器上，例如`Quill`是完全自行实现的视图`DOM`绘制，而`Slate`是借助于`React`实现的视图层，这两者对于视图层的实现方式有很大的不同，在本文中是偏向于`Slate`的实现方式，也就是借助于`React`来构建块级别的虚拟滚动，当然实际上如果能够完全控制视图层的话，对于性能可优化的空间会更大，例如可以更方便地调度闲时渲染配合缓存等策略，从而更好地优化快速滚动时的体验。实际上无论是哪种方式，对于本文要讲的核心内容差距并没有那么大，只要我们能够保证富文本引擎本身控制的选区模块、高度计算模块、生命周期模块等正确调度，以及能够控制实际渲染行为，无论是哪种编辑器引擎都是可以应用虚拟滚动方案的。

### 渲染模型
首先我们来构思一下整个文档的渲染模型，无论是基于块模型的编辑器还是基于段落描述的编辑器都脱离不了行的概念，因为我们描述内容的时候通常都是由行来组成的一篇文档的，所以我们的文档渲染也都是以行为基准来描述的。当然这里的行只是一个比较抽象的概念，这个行结构内嵌套的可能是个块结构的表达例如代码块、表格等等，而无论是如何嵌套块，其最外层总会是需要包裹行结构的表达，即使是纯`Blocks`的文档模型，我们也总能够找到外层的块容器`DOM`结构，所以我们在这里需要明确定义行的概念。

实际上在此处我们所关注的行更倾向于主文档直属的行描述，而如果在主文档的某个行中嵌套了代码块结构，这个代码块的整个块结构是我们要关注的，而对于这个代码块结构的内部我们先不做太多关注，当然这是可以进一步优化的方向，特别是对于超大代码块的场景是有必要的，但是我们在这里先不关注这部分结构优化。此外，对于`Canvas`绘制的文档或者是类似于分页表达的文档同样不在我们的关注范围内，只要是能够通过分页表达的文章，我们直接通过页的按需渲染即可，当然如果有需要的话同样也可以进行段落级别的按需渲染，这同样也可以算作是进一步的优化空间。

那么我们可以很轻松地推断出我们文档最终要渲染的结构，首先是占位区域`placeholder`，这部分内容是不在视口的区域，所以会以占位的方式存在；紧接着是`buffer`，这部分是提前渲染的内容，即虽然此区域不在视口区域，但是为了用户在滚动时尽量避免出现短暂白屏的现象，由此提前加载部分视图内容，通常这部分值可以取得视口高度的一半大小；接下来是`viewport`部分，这部分是真实在视口区域要渲染的内容；而在视口区域下我们同样需要`buffer`和`placeholder`来作为预加载与占位区域。

```
placeholder 
   |
 buffer
   | 
viewpoint 
   |
 buffer
   | 
placeholder
```

需要注意的是，在这里的`placeholder`我们通常会选择直接使用`DOM`进行占位，可能大家会想着如果直接使用`translate`是更好的选择，效率会高一些并且能触发`GPU`加速，实际上对于普通的虚拟列表是没什么问题的，但是在文档结构中`DOM`结构会比较复杂，使用`translate`可能会出现一些预期之外的情况，特别是在复杂的样式结构中，所以使用`DOM`进行占位是比较简单的方式。此外，因为选区模块的存在，在实现`placeholder`的时候还需要考虑用户拖拽长选区的情况，也就是说如果用户在进行选择操作时将`viewport`的部分选择并不断滚动，然后直接将其拖拽到了`placeholder`区域，此时如果不特殊处理的话，这部分`DOM`会消失且会并作占位`DOM`节点，此时选区则会出现问题无法映射到`Model`，所以我们需要在用户选择的时候保留这部分`DOM`节点，且在这里使用`DOM`进行占位会方便一些，使用`translate`适配起来相对就麻烦不少，因此此时的渲染模型如下所示。

```
  placeholder 
      |
selection.anchor 
      |
  placeholder 
      |
    buffer
      | 
   viewpoint 
      |
   buffer
      | 
  placeholder 
      |
selection.focus 
      |
  placeholder 
```

### 滚动调度
虚拟滚动的实现方式本质上就是在用户滚动视图时，根据视口的高度、滚动容器的滚动距离、行的高度等信息计算出当前视口内需要渲染的行，然后在视图层根据计算的状态来决定是否要渲染。而在浏览器中关于虚拟滚动常用的两个`API`就是`Scroll Event`与`Intersection Observer API`，前者是通过监听滚动事件来计算视口的位置，后者是通过观察元素的可见性来判断元素位置，基于这两种`API`我们可以分别实现虚拟滚动的不同方案。

首先我们来看`Scroll Event`，这是最常见的滚动监听方式，通过监听滚动事件我们可以获取到滚动容器的滚动距离，然后通过计算视口的高度与滚动距离来计算出当前视口内需要渲染的行，然后在视图层根据计算的状态来决定是否要渲染。实际上基于`Scroll`事件监听来单纯地实现虚拟滚动方案非常简单，当然同样的也更加容易出现性能问题，即使是标记为`Passive Event`可能仍然会存在卡顿问题。其核心思路是通过监听滚动容器的滚动事件，当滚动事件触发时，我们需要根据滚动的位置来计算当前视口内的节点，然后根据节点的高度来计算实际需要渲染的节点，从而实现虚拟滚动。

在前边也提到了，针对于固定高度的虚拟滚动是比较容易实现的，然而我们的文档块是动态高度的，在块未实际渲染之前我们无法得到其真实高度。那么动态高度的虚拟滚动与固定高度的虚拟滚动区别有什么，首先是滚动容器的高度，我们在最开始不能够知道滚动容器实际有多高，而是在不断渲染的过程中才能知道实际高度；其次我们不能直接根据滚动的高度计算出当前需要渲染的节点，在固定高度时我们渲染的起始`index`游标是直接根据滚动容器高度和列表所有节点总高度算出来的，而在动态高度的虚拟滚动中，我们无法获得总高度，同样的渲染节点的长度也是如此，我们无法得知本次渲染究竟需要渲染多少节点；再有我们不容易判断节点距离滚动容器顶部的高度，也就是之前我们提到的`translateY`，我们需要使用这个高度来撑起滚动的区域，从而让我们能够实际做到滚动。

那么我们说的这些数值都是无法计算的嘛，显然不是这样的，在我们没有任何优化的情况下，这些数据都是可以强行遍历计算的。那么我们就来想办法计算一下上述的内容，根据我们前边聊的试想一下，对于文档来说无非就是基于块的虚拟滚动罢了，那么总高度我们可以直接通过所有的块的高度相加即可，在这里需要注意的是即使我们在未渲染的情况下无法得到其高度，但是我们却是可以根据数据结构推算其大概高度，在实际渲染时纠正其高度即可。记得之前提到的我们是直接使用占位块的方式来撑起滚动区域，那么此时我们就需要根据首尾游标来计算具体占位，具体的游标值我们后边再计算，现在我们先分别计算两个占位节点的高度值，并且将其渲染到占位位置。

```js
const startPlaceHolderHeight = useMemo(() => {
  return heightTable.slice(0, start).reduce((a, b) => a + b, 0);
}, [heightTable, start]);

const endPlaceHolderHeight = useMemo(() => {
  return heightTable.slice(end, heightTable.length).reduce((a, b) => a + b, 0);
}, [end, heightTable]);

return (
  <div
    style={{ height: 500, border: "1px solid #aaa", overflow: "auto", overflowAnchor: "none" }}
    onScroll={onScroll.run}
    ref={onUpdateInformation}
  >
    <div data-index={`0-${start}`} style={{ height: startPlaceHolderHeight }}></div>
    {/* ... */}
    <div data-index={`${end}-${list.length}`} style={{ height: endPlaceHolderHeight }}></div>
  </div>
);
```

那么大概估算的总高度已经得到了，接下来处理首尾的游标位置也就是实际要渲染块的`index`，对于首部游标我们直接根据滚动的高度来计算即可，遍历到首个节点的高度大于滚动高度时，我们就可以认为此时的游标就是我们需要渲染的首个节点，而对于尾部游标我们需要根据首部游标以及滚动容器的高度来计算，同样也是遍历到超出滚动容器高度的节点时，我们就可以认为此时的游标就是我们需要渲染的尾部节点。当然，在这游标的计算中别忘了我们的`buffer`数据，这是尽量避免滚动时出现空白区域的关键。此外，在这里我们都是采用暴力的方式相加计算的，对于现代机器与浏览器来说，执行加法计算需要的性能消耗并不是很高，例如我们实现`1`万次加法运算，实际上的时间消耗可能也只有不到`1ms`。

```js
const getStartIndex = (top: number) => {
  const topStart = top - buffer.current;
  let count = 0;
  let index = 0;
  while (count < topStart) {
    count = count + heightTable[index];
    index++;
  }
  return index;
};

const getEndIndex = (clientHeight: number, startIndex: number) => {
  const topEnd = clientHeight + buffer.current;
  let count = 0;
  let index = startIndex;
  while (count < topEnd) {
    count = count + heightTable[index];
    index++;
  }
  return index;
};

const onScroll = useThrottleFn(
  () => {
    if (!scroll) return void 0;
    const scrollTop = scroll.scrollTop;
    const clientHeight = scroll.clientHeight;
    const startIndex = getStartIndex(scrollTop);
    const endIndex = getEndIndex(clientHeight, startIndex);
    // ...
  },
);
```

在这里我们聊的是虚拟滚动最基本的原理，所以在这里的示例中基本没有什么优化，显而易见的是我们对于高度的遍历处理是比较低效的，即使进行万次加法计算的消耗并不大，但是在大型应用中还是应该尽量避免做如此大量的计算，特别是`Scroll Event`实际上触发频率相当高的情况下。那么显而易见的一个优化方向是我们可以实现高度的缓存，简单来说就是对于已经计算过的高度我们可以缓存下来，这样在下次计算时就可以直接使用缓存的高度，而不需要再次遍历计算，而出现高度变化需要更新时，我们可以从当前节点到最新的缓存节点之间，重新计算缓存高度。而且这种方式相当于是递增的有序数组，还可以通过二分等方式解决查找的问题，这样就可以尽可能地避免大量的遍历计算。

```
height: 10 20 30 40  50  60  ...
cache:  10 30 60 100 150 210 ...
```

`IntersectionObserver`现如今已经被标记为`Baseline Widely Available`，在`March 2019`之后发布的浏览器都已经实现了该`API`现已并且非常成熟。接下来我们来看下`Intersection Observer API`的虚拟滚动实现方式，不过在具体实现之前我们先来看看`IntersectionObserver`具体的应用场景。根据名字我们可以看到`Intersection`与`Observer`两个单词，由此我们可以大概推断这个`API`的主要目标是观测目标的交叉状态，而实际上`IntersectionObserver`就是用以异步地观察目标元素与其祖先元素或顶级文档视口的交叉状态，这对判断元素是否出现在视口范围非常有用。

那么在这里我们需要关注一个问题，`IntersectionObserver`对象的应用场景是观察目标元素与视口的交叉状态，而我们的虚拟滚动核心概念是不渲染非视口区域的元素。所以这里边实际上出现了一个偏差，在虚拟滚动中目标元素都不存在或者说并未渲染，那么此时是无法观察其状态的。所以为了配合`IntersectionObserver`的概念，我们需要渲染实际的占位节点，例如`10k`个列表的节点，我们首先就需要渲染`10k`个占位节点，实际上这也是一件合理的事，除非我们最开始就注意到文档的性能问题，而实际上大部分都是后期优化文档性能，特别是在复杂的场景下。假设原本有`1w`条数据，每条数据即使仅渲染`3`个节点，那么此时我们如果仅渲染占位节点的情况下还能将原本页面`30k`个节点优化到大概`10k`个节点。这对于性能提升本身也是非常有意义的，且如果有需要的话还能继续进行完整的性能优化。

当然如果不使用占位节点的话实际上也是可以借助`Intersection Observer`来实现虚拟滚动的，只不过这种情况下需要借助`Scroll Event`来辅助实现强制刷新的一些操作，整体实现起来还是比较麻烦的。所以接下来我们还是来实现一下基于`IntersectionObserver`的占位节点虚拟滚动方案，首先需要创建`IntersectionObserver`，同样的因为我们的滚动容器可能并不一定是`window`，所以我们需要在滚动容器上创建`IntersectionObserver`，此外根据前边聊的我们会对视口区域做一层`buffer`，用来提前加载视口外的元素，这样可以避免用户滚动时出现空白区域，这个`buffer`的大小通常选择当前视口高度的一半。

```js
useLayoutEffect(() => {
  if (!scroll) return void 0;
  // 视口阈值 取滚动容器高度的一半
  const margin = scroll.clientHeight / 2;
  const current = new IntersectionObserver(onIntersect, {
    root: scroll,
    rootMargin: `${margin}px 0px`,
  });
  setObserver(current);
  return () => {
    current.disconnect();
  };
}, [onIntersect, scroll]);
```

接下来我们需要对占位节点的状态进行管理，因为我们此时有实际占位，所以就不再需要预估整个容器的高度，而且只需要实际滚动到相关位置将节点渲染即可。我们为节点设置三个状态，`loading`状态即占位状态，此时节点只渲染空的占位节点也可以渲染一个`loading`标识，此时我们还不知道这个节点的实际高度；`viewport`状态即为节点真实渲染状态，也就是说节点在逻辑视口内，此时我们可以记录节点的真实高度；`placeholder`状态为渲染后的占位状态，相当于节点从在视口内滚动到了视口外，此时节点的高度已经被记录，我们可以将节点的高度设置为真实高度。

```
loading -> viewport <-> placeholder
```

```js
type NodeState = {
  mode: "loading" | "placeholder" | "viewport";
  height: number;
};

public changeStatus = (mode: NodeState["mode"], height: number): void => {
  this.setState({ mode, height: height || this.state.height });
};

render() {
  return (
    <div ref={this.ref} data-state={this.state.mode}>
      {this.state.mode === "loading" && (
        <div style={{ height: this.state.height }}>loading...</div>
      )}
      {this.state.mode === "placeholder" && <div style={{ height: this.state.height }}></div>}
      {this.state.mode === "viewport" && this.props.content}
    </div>
  );
}
```

当然我们的`Observer`的观察同样需要配置，这里需要注意的是`IntersectionObserver`的回调函数只会携带`target`节点信息，我们需要通过节点信息找到我们实际的`Node`来管理节点状态，所以此处我们借助`WeakMap`来建立元素到节点的关系，从而方便我们处理。

```js
export const ELEMENT_TO_NODE = new WeakMap<Element, Node>();

componentDidMount(): void {
  const el = this.ref.current;
  if (!el) return void 0;
  ELEMENT_TO_NODE.set(el, this);
  this.observer.observe(el);
}

componentWillUnmount(): void {
  const el = this.ref.current;
  if (!el) return void 0;
  this.observer.unobserve(el);
}
```

最后就是实际滚动调度了，当节点出现在视口时我们需要根据`ELEMENT_TO_NODE`获取节点信息，然后根据当前视口信息来设置状态，如果当前节点是进入视口的状态我们就将节点状态设置为`viewport`，如果此时是出视口的状态则需要二次判断当前状态，如果不是初始的`loading`状态则可以直接将高度与`placeholder`设置到节点状态上，此时节点的高度就是实际高度。

```js
const onIntersect = useMemoizedFn((entries: IntersectionObserverEntry[]) => {
  entries.forEach(entry => {
    const node = ELEMENT_TO_NODE.get(entry.target);
    if (!node) {
      console.warn("Node Not Found", entry.target);
      return void 0;
    }
    const rect = entry.boundingClientRect;
    if (entry.isIntersecting || entry.intersectionRatio > 0) {
      // 进入视口
      node.changeStatus("viewport", rect.height);
    } else {
      // 脱离视口
      if (node.state.mode !== "loading") {
        node.changeStatus("placeholder", rect.height);
      }
    }
  });
});
```

实际上在本文中继续聊到的性能优化方式都是基于`Intersection Observer API`实现的的，在文档中每个块可能会存在上百个节点，特别是在表格这种复杂的表达中，而且主文档下直属的块或者说行数量通常不会很多，所以这对于节点数量的优化是非常可观的。在之前我在知乎上看到了一个问题，为什么`Python`内置的`Sort`比自己写的快速排序快`100`倍，以至于我每次看到`Intersection Observer API`都会想到这个问题，实际上这其中有个很大的原因是`Python`标准库是用`C/C++`实现的，其执行效率本身就比`Python`这种解释型脚本语言要高得多，而`Intersection Observer API`也是同样的问题，其是浏览器底层用`C/C++`实现的，执行效率比我们使用`JS`调度滚动要高不少，不过也许在`JIT`编译的加持下可能差距没那么大。

### 状态管理
在我们的文档编辑器中，虚拟滚动不仅仅是简单的滚动渲染，还需要考虑到各种状态的管理。通常我们的编辑器中是已经存在块管理器的，也就是基于各种`changes`来管理整个`Block Tree`的状态，实际上也就是对于树结构的增删改查，例如当触发的`op`为`insert { parentId: xxx, id: yyy }`时我们就需要在`xxx`这个节点下加入新的`yyy`节点。实际上在这里的的树结构管理还是比较看具体业务实现的，如果编辑器为了`undo/redo`的方便而不实际在树中删除某个块，仅仅是标记为已/未删除的状态，那么这个块管理器的状态管理就变成了只增不删，所以在这里基于`Block`的管理器还是需要看具体编辑器引擎的实现。

那么在这里我们需要关注的是在这个`Block Engine`上的拓展，我们需要为其增加虚拟滚动的状态，也就是为其拓展出新的状态。当然如果仅仅是加新的状态的话可能就只是个简单的问题，在我们还需要关注块结构嵌套的问题，为我们后边的场景推演作下准备。在前边提到过，我们当前关注的是主文档直属的块管理，那么对于嵌套的结构来说，当直属块处于占位状态时，我们需要将其内部所有嵌套的块都设置为占位状态。这本身会是个递归的检查过程，且本身可能会存在大量调用，所以我们需要为其做一层缓存来减少重复计算。

在这里我们的思路是在每个节点都设置缓存，这个缓存存储了所有的子树节点的引用，是比较典型的空间换时间，当然因为存储的是引用所以空间消耗也不大。这样带来的优势是，例如用户一直在修改某个块子节点的结构，在每个节点进行缓存仅会重新计算该节点的内容，而其他子节点则会直接取缓存内容，不需要重新计算。在这里需要注意的是，当对当前节点进行`append`或者`remove`子节点时，需要将该节点以及该节点所有父层节点链路上的所有缓存清理掉，在下次调用时按需重新计算。实际上因为我们整个编辑器都是基于`changes`来调度的，所以做到细粒度的结构管理并不是非常困难的事。

```js
public getFlatNode() {
  if (this.flatNodes) return this.flatNodes;
  const nodes: Node[] = [];
  this.children.forEach(node => {
    nodes.push(node);
    nodes.push(...node.getFlatNode());
  });
  this.flatNodes = nodes;
  return nodes;
}

public clearFlatNode() {
  this.flatNodes = null;
}

public clearFlatNodeOnLink() {
  this.clearFlatNode();
  let node: Node | null = this.parent;
  while (node) {
    node.clearFlatNode();
    node = node.parent;
  }
}
```

那么我们现在已经有了完整的块管理器，接下来我们需要思考如何调度控制渲染这个行为，如果我们的编辑器引擎是自研的视图层，那么可控性肯定是非常高的，无论是控制渲染行为还是实现渲染缓存都不是什么困难的事情，但是前边我们也提到了在本身是更倾向于用`React`作为视图层来实现调度，所以在这里我们需要更通用的管理方案。实际上用`React`作为视图层的优势是可以借助生态实现比较丰富的自定义视图渲染，但是问题就是比较难以控制，在这里不光指的是渲染的调度行为，还有`Model <-> View`映射与`ContentEditable`原地复用带来的一些问题，不过这些不是本文要聊的重点，我们先来聊下比较通用的渲染控制方式。

首先我们来设想一下在`React`中应该如何控制`DOM`节点的渲染，很明显我们可以通过`State`来管理渲染状态，或者是通过`ReactDOM.render/unmountComponentAtNode`来控制渲染渲染，至于通过`Ref`来直接操作`DOM`这种方式会比较难以控制，可能并不是比较好的管理方式。我们先来看一下`ReactDOM.render/unmountComponentAtNode`，这个`API`在`React18`被标记为`deprecated`了，后边还有可能会变化，但是这不是主要问题，最主要的是使用`render`会导致无法直接共享`Context`，也就是其会脱离原本的`React Tree`，必须要重新将`Context`并入才可以，这样的改造成本显然是不合适的。

因此最终我们还是通过`State`来控制渲染状态，那么此时我们还需要文档全局的管理器来控制所有块节点的状态，那么在`React`中很明显我们可以通过`Context`来完成这件事，通过全局的状态变化来影响各个`ReactNode`的状态。但是这样实际上将控制权交给了各个子节点来管理自身的状态，我们可能是希望拥有一个全局的控制器来管理所有的块。那么为了实现这一点，我们就实现`LayoutModule`模块来管理所有节点，而对于节点本身，我们需要为其包裹一层`HOC`，且为了方便我们选择类组件来完成这件事，由此我们便可以通过`LayoutModule`模块来管理所有块结构实例的状态。

```js
class LayoutModule{
  private instances: Map<string, HOC> = new Map();
  // ...
}

class HOC extends React.PureComponent<Props> {
  public readonly id: string;
  public readonly layout: LayoutModule;
  // ...
  constructor(props: Props) {
    // ...
    this.layout.add(this);
  }
  componentWillUnmount(): void {
    this.layout.remove(this);
    // ...
  }
  // ...
}
```

使用类组件的话，整个组件实例化之后就是对象，可以比较方便地写函数调用以及状态控制，当然这些实现通过函数组件也是可以做到的，只是用类组件会更方便些。那么接下来我们就可以通过类方法控制其状态，此外我们还需要通过`ref`来获得当前组件需要观察的节点。如果使用`ReactDOM.findDOMNode(this)`是可以在类组件中获得`DOM`的引用的，但是同样也被标记为`deprecated`了，所以还是不建议使用，所以在这里我们还是通过包裹一层`DOM`并且观察这层`DOM`来实现虚拟滚动。此外，要注意到实际上我们的`DOM`渲染是由`React`控制的，对于我们的应用来说是不可控的，所以我们还需要记录`prevRef`来观测到`DOM`引用发生变化时，将`IntersectionObserver`的观察对象进行更新。

```js
type NodeState = {
  mode: "loading" | "placeholder" | "viewport";
  height: number;
};

class HOC extends React.PureComponent<Props> {
  public prevRef: HTMLDivElement | null;
  public ref: React.RefObject<HTMLDivElement>;
  // ...
  componentDidUpdate(prevProps: Props, prevState: State): void {
    if (this.prevProps !== this.ref.current) {
      this.layout.updateObserveDOM(this.prevProps, this.ref.current);
      this.prevProps = this.ref.current;
    }
  }
  public changeStatus = (mode: NodeState["mode"], height: number): void => {
    this.setState({ mode, height: height || this.state.height });
  };
  // ...
  render() {
    return (
      <div ref={this.ref} data-state={this.state.mode}>
        {/* ... */}
      </div>
    );
  }
}
```

### 选区状态
在选区模块中，我们需要保证视图的状态能够正确映射到`Model`上，由于在虚拟滚动的过程中`DOM`可能并不会真正渲染到页面上，而浏览器的选区表达则是需要`anchorNode`节点与`focusNode`节点共同确定的，所以我们就需要保证在用户选中的过程中这两个节点是正常表现在`DOM`树结构中。实现这部分能力实际上并不复杂，只要我们理解浏览器的选区模型，并且由此保证`anchorNode`节点与`focusNode`节点是正常渲染的即可，通过保证节点正确渲染则我们就不需要在虚拟滚动的场景下去重新设计选区模型，据此我们来需要推演一些场景。

* 视口内选择: 当用户在视口内选择相关块的时候，我们可以认为这部分选区在有无虚拟滚动的情况下都是正常处理的，不需要额外推演场景，保持原本的`View Model`映射逻辑即可。
* 选区滚动到视口外: 当用户选择内容时正常在视口中选择，此时选区是正常选择，但是后来用户将视口区域进行滚动，导致选区部分滚动到了视口外，此时我们需要保留选区状态，否则当用户滚动回来时会导致选区丢失。那么在这种情况下我们就需要保证选区的`anchorNode`节点与`focusNode`节点正确渲染，如果粒度粗则保证其所在的块是正常渲染即可。
* 拖拽选择长选区: 当用户进行`MouseDown`时`anchorNode`在视口内，此时用户通过拖拽操作导致页面滚动，从而将`anchorNode`拖拽到视口外部。同样的，此时我们需要保证`anchorNode`所在的块/节点即使不在视口区域也需要正常渲染，否则会导致选区丢失。
* 触发选区更新: 当因为某些操作导致选区中的内容更新时，例如通过编辑器的`API`操作了文档内容，此时将出现两种情况，如果更新的内容不是`anchorNode`节点或者`focusNode`节点，那么对于整体选区不会造成影响，否则我们需要在渲染完成后通过`Model`重新校正选区节点。
* 全选操作: 对于全选操作我们可以认为是特殊的选区行为，我们需要保证文档的首尾的行/块节点完整渲染，所以在这里的流程是需要通过`Model`获得首尾节点的状态，然后强制将这两部分渲染出来，由此保证`anchorNode`节点与`focusNode`节点正确渲染出来，接下来再走正常的选区映射逻辑即可。

实际上，还记得我们的`Intersection Observer API`通常是需要占位节点来实现虚拟滚动的，那么既然占位节点本身都在这里，如果我们并不特别注意`DOM`节点的数量的话，是可以在占位的时候将`Block`的选区标识节点一并渲染出来的，这样可以解决一些问题，例如全选的操作就可以不需要特殊处理。如果我们将范围放的再宽泛一些的话，将文本块以及`Void/Embed`结构`\u200B`节点在占位的时候也一并渲染出来，只对于复杂块进行渲染调度，这种情况下我们甚至可以不需要关心选区的问题，此时需要标记的选区映射节点都已经渲染出来了，我们只需要关注复杂块虚拟滚动的调度即可。

### 视口锁定
overflow-anchor
scrollRestoration
Resize
margin

### 快速滚动
快速滚动 与 闲时渲染

### 增量渲染
状态控制 
事件触发

## 场景推演
单独实现虚拟滚动是不够的 必须要为虚拟滚动做`API`兼容

### 锚点跳转
锁视口 提前渲染

### 搜索替换
VirtualLayer现场渲染 不可替换内容 滚动动画调度

### 评论能力
更新评论位置 按需更新

## 性能考量
在我们兼容完成各类功能之后 必须要对这个需求进行性能考量 ROI

### 性能指标
LCP TTI

### 性能测试
块数量分级测试

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-anchor
https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver
https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry
https://developer.mozilla.org/zh-CN/docs/Web/API/History/scrollRestoration
https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
https://arco.design/react/components/list#%E6%97%A0%E9%99%90%E9%95%BF%E5%88%97%E8%A1%A8
```

