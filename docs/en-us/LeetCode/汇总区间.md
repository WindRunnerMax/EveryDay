## Summary Range
Given an ordered integer array `nums` with no duplicate elements.

Return a list of minimum ordered range intervals that exactly cover all the numbers in the array. In other words, each element of `nums` is exactly covered by a certain range interval, and there is no number `x` that belongs to a certain range interval but does not belong to `nums`.

Each interval range `[a,b]` in the list should be formatted as follows:

* `"a->b"` , if `a != b`.
* `"a"` , if `a == b`.

## Example

```
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The interval ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

```
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The interval ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

```
Input: nums = []
Output: []
```

```
Input: nums = [-1]
Output: ["-1"]
```

```
Input: nums = [0]
Output: ["0"]
```


## Solution

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    const n = nums.length;
    if(n === 0) return nums;
    if(n === 1) return [String(nums[0])];
    let left = nums[0];
    let right = nums[0];
    const target = [];
    for (let i=1; i<=n; i++){
        const cur = nums[i];
        const pre = nums[i-1];
        if (cur - pre === 1){
            right = cur;
        }else if(left === right){
            target.push(String(left));
            left = cur;
            right = cur;
        }else{
            target.push([left, "->", right].join(""));
            left = cur;
            right = cur;
        }
    }
    return target;
};

/**
var summaryRanges = function(nums) {
    const n = nums.length;
    if(n === 0) return nums;
    if(n === 1) return [String(nums[0])];
    let sequence = nums[0];
    let unit = [sequence];
    let pre = sequence;
    const target = [];
    nums.forEach((v, i) => {
        if(v !== sequence++){
            if(unit[0] !== pre) unit.push(pre);
            sequence = v + 1;
            target.push(unit.join("->"));
            unit = [v];
        }
        pre = v;
    })
    if(unit[0] !== nums[n-1]) unit.push(nums[n-1]);
    target.push(unit.join("->"))
    return target;
};
 */
```

## Idea
In this problem, it is particularly important to note the situation when two values are equal, only one value should be placed. The idea below is my previous approach, using an increasing sequence value as a comparison with the original sequence value to complete the comparison. Special care needs to be taken in the case when two values are equal. The new idea below is a relatively simpler approach. It uses two pointers. If the difference is one, the right pointer moves forward one position. If the difference is greater than one, it pushes an interval into the array, then the left and right pointers point to the next value for further traversal. First, define the array length. Then, if the array length is `0`, simply return the array. If the array length is `1`, return the value as a string. Then define the left and right pointers, as well as the target array. Establish a loop. In `Js`, there is no need to worry too much about out-of-bounds situations. When comparing later, treat it as `undefined`. Define the current value and the previous value. If the difference between the two values is `1`, move the right pointer. If the two pointers are equal, convert one of the values to a string and push it into the target array, then set both pointers to the current value. If the difference is not `1` and they are not the same, push it into the array as the required string, and set both pointers to the current value. Once the loop ends, return the target array.

## Daily Problem

```markdown
[https://github.com/WindrunnerMax/EveryDay](https://github.com/WindrunnerMax/EveryDay)

## Reference

[https://leetcode-cn.com/problems/summary-ranges/](https://leetcode-cn.com/problems/summary-ranges/)
```