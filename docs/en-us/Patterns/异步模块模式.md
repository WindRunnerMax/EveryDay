```html
    // 封装F模块
    function F() {
        const args = Array.prototype.slice.call(arguments),
            callback = args.pop(),
            modules = args[0] && typeof args[0] === "string" ? args : args[0],
            len = modules.length,
            __modules = [],
            module = "",
            i = 0;
        
        while (i < len) {
            module = modules[i];
            moduleCache[module] && module.status !== "loaded" ? __modules.push(module) : (moduleCache[module] = {
                status: "loaded",
                exports: null,
                onload: []
            }, __modules.push(module), loadScript(getUrl(module)));
            i++
        }

        for (i = 0; i < len; i++) {
            module = moduleCache[modules[i]];
            if (module) {
                __modules[i] = module.exports;
            } else {
                module.onload.push(function() {
                    return setModule.apply(null, [modules[i]].concat(slice.call(arguments)))
                })
            }
        }
        callback.apply(null, __modules)
    }
    window.F = F;
})(window));
</script>
</html>
```

```javascript
function loadModule(moduleName, callback) {
    let _module = "";
    if (moduleCache[moduleName]) {
        _module = moduleCache[moduleName];
        if (_module.status === "loaded") {
            // This is important, loadModule must be asynchronous. It's mentioned in effectiveJS, never call an async function synchronously, it's very important.
            setTimeout(callback(_module.exports), 0);
        } else {
            // Call when the loading is completed
            _module.onload.push(callback);
        }
    } else {
        // First time loading
        moduleCache[moduleName] = {
            moduleName: moduleName,
            status: "loading",
            exports: null,
            onload: [callback]
        };
        loadScript(getUrl(moduleName));
    }
}

F.module = function(...args) {
    // Get the module constructor function (last member of the parameter array)
    let callback = args.pop();
    // Get dependent modules (adjacent to the callback function parameter, and the data type is an array)
    let deps = (args.length && args[args.length - 1] instanceof Array) ? args.pop() : [];
    // Module URL (module ID)
    let url = args.length ? args.pop() : null;
    // Dependent module sequence
    let params = [];
    // Count of unloaded dependent modules
    let depsCount = 0;

    if(deps.length) {
        deps.forEach((v ,i) => {
            // Increase the count of unloaded dependent modules
            depsCount++;
            // Asynchronously load dependent modules
            loadModule(deps[i], function(mod) {
                // Decrease the count of dependent modules in the sequence by one
                depsCount--;
                params[i] = mod;
                // If all dependent modules are loaded
                if(depsCount === 0) {
                    // Correct the module in the module cache, and execute the constructor function
                    setModule(url, params, callback);
                }
            });
        })     
    } else { // No dependent modules, directly execute the callback function
        // Correct the module in the module cache, and execute the constructor function
        setModule(url, [], callback);
    }
}

})((() => window.F = ({}))());


F.module(["./event", "./dom"], function(events, dom) {
    console.log(events, dom)
    events.on("demo", "click", function() {
        dom.html("demo", "success");
    })
});
</script>

</html>
```



## Daily Question

```
https://github.com/WindrunnerMax/EveryDay
```

## Reference


```
https://www.jianshu.com/p/d71fc902051e
https://blog.csdn.net/WuLex/article/details/107350493
https://blog.csdn.net/a545415/article/details/77930534
```