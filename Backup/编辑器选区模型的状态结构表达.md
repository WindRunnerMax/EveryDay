# 编辑器选区模型的状态结构表达
先前我们总结了浏览器选区模型的交互策略，并且实现了基本的选区操作，还调研了自绘选区的实现。那么相对的，我们还需要设计编辑器的选区表达，也可以称为模型选区。编辑器中应用变更时的操作范围，就是以模型选区为基准来实现的。在这里我们就以编辑器状态为基础，来设计模型选区的结构表达。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

从零实现富文本编辑器项目的相关文章:

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)

## 编辑器选区模型
在编辑器中的选区模型设计是涉及面比较广的命题，因为其作为应用变更或者称为执行命令的基础范围，涉及到了广泛的模块交互。虽然本质上是需要其他模块需要适配选区模型的表达，但明显的如果选区模型不够清晰的话，其他模块的适配工作就会变得复杂，交互自然是需要相互配合来实现的。

而选区模型最直接依赖的就是编辑器的状态模型，而状态模型的设计又非常依赖数据结构的设计。因此，在这里我们会从数据结构以及状态模型的角度出发，先来调研一下当前主流编辑器的选区模型设计。

### Quill
`Quill`是一个现代富文本编辑器，具备良好的兼容性及强大的可扩展性，还提供了部分开箱即用的功能。`Quill`的出现给富文本编辑器带了很多新的东西，也是目前开源编辑器里面受众非常大的一款编辑器，至今为止的生态已经非常的丰富，目前也推出了`2.0`版本。

`Quill`的数据结构表达是基于`Delta`实现的，当然既然其名为`Delta`，那么数据的变更也可以基于`Delta`来实现。那么使用`Delta`表达基本的富文本数据结构如下所示，可以观察到其不会存在嵌套的数据结构表达，所有内容以及格式表达都是线性的。

```js
{
  ops: [
    { insert: "这样" },
    { insert: "一段文本", attributes: { italic: true } },
    { insert: "的" },
    { insert: "数据结构", attributes: { bold: true } },
    { insert: "如下所示。\n" },
  ],
};
```

既然数据结构是扁平的表达，那么选区的表达也不需要复杂的结构来实现。直观感受上来说，扁平化结构要特殊处理的`Case`会更少，状态结构会更好维护，编辑器架构会更加轻量。通常编辑器的选区也会构造`Range`对象，那么在`Quill`中的选区结构如下所示:

```js
{
  index: 5, // 光标位置
  length: 10, // 选区长度
}
```

选区作为编辑器变更的应用范围，不可避免地需要提及应用变更的操作。在应用变更时，自然需要进行状态结构的遍历，以取出需要变更的节点来实际应用变更。那么自然而然地，扁平的结构本身的顺序就是渲染的顺序，不需要嵌套的结构来进行递归地查找，查找的效率自然会更高。

此外，`Quill`的视图层是重新设计了一套模型`parchment`，维护了视图和状态模型，虽然在仓库中通过继承的方式重写了部分类结构，例如`ScrollBlot`类。但是在阅读源码的时候难以确定很多视图模块设计意图，所以对于`DOM`事件与状态模型的交互暂时还没有很好的理解。

### Slate
`Slate`是一个高度灵活、完全可定制的富文本编辑器框架，其提供了一套核心模型和`API`，让开发者能够深度定制编辑器的行为，其更像是富文本编辑器的引擎，而不是开箱即用的组件。`Slate`经历过一次大版本重构，虽然目前仍然处于`Beta`状态，但是已经有相当多的线上服务使用。

`Slate`的数据结构表达就不是扁平的内容表示的，依据其`TS`类型的定义，`Node`类型是`Editor | Element | Text`三种类型的元组。当然抛开`Editor`本身不谈，我们从下面的内容描述上可以很容易看出来`Element`和`Text`类型的定义。

```js
{
  type: "paragraph",
  children: [
    { text: "这样" },
    { text: "一段文本", italic: true },
    { text: "的" },
    { text: "数据结构", bold: true },
    { text: "如下所示。" },
  ]
}
```

其中`children`属性可以认为是`Element`类型的节点，而`text`属性则是`Text`类型的节点，`Element`类型的节点可以无限嵌套`Element`类型以及`Text`类型节点。那么这种情况下，扁平的选区表达就无法承载这样的结构，因此`Slate`的选区表达是用端点来实现的。

```js
{
  anchor: { path: [0, 1], offset: 2 }, // 起始位置
  focus: { path: [0, 3], offset: 4 }, // 结束位置
}
```

这种选区的表达是不是非常眼熟，没错`Slate`的选区表达是完全与浏览器选区对齐的，因为其从最开始的设计原则就是与`DOM`对齐的。说句题外的话，`Slate`对于数据结构的表现也是完全与选区对齐的，例如表达图片时必须要放置一个空的`Text`作为零宽字符。

```js
{
  type: "image",
  url: "https://example.com/image.png",
  children: [{ text: "" }]
}
```

```html
<div data-slate-node="element" data-slate-void="true">
  <div data-slate-spacer="true">
    <span data-slate-zero-width="z" data-slate-length="0">\u200B</span>
  </div>
  <div contenteditable="false">
    <img src="https://example.com/image.png">
  </div>
</div>
```

除了类似于图片的`Void`节点表达，针对于行内的`Void`节点，更能够表现其内建维护的数据结构是完全对齐`DOM`的。例如下面的`Mention`结构表达，由于需要在两侧放置光标，因此在`DOM`中引入了两个零宽字符，此时内建数据结构也维护了两个`Text`节点。

```js
[
  { text: "" },
  {
    type: "mention",
    user: "Mace",
    children: [{ text: "" }],
  },
  { text: "" },
];
```

```html
<p data-slate-node="element">
  <span data-slate-node="text">
    <span data-slate-zero-width="z" data-slate-length="0">\u200B</span>
  </span>
  <span contenteditable="false">
    <span data-slate-spacer="true">
      <span data-slate-zero-width="z" data-slate-length="0">\u200B</span>
    </span>
    @Mace
  </span>
  <span data-slate-node="text">
    <span data-slate-zero-width="z" data-slate-length="0">\u200B</span>
  </span>
</p>
```

说回选区模型，`Slate`在应用数据变更时，同样需要依赖两个端点来进行遍历查找，特别是进行诸如`setNode`等操作时。那么查找就非常依赖渲染顺序来决定，由于文档整体结构还是二维的，因此通过`path + offset`对比找到起始/结束的节点，然后从首节点开始递归遍历查找到尾节点就可以了。


### Lexical
`Lexical`是`Meta`开源的现代化富文本编辑器框架，专注于提供极致的性能、可访问性和可靠性。其作为`Draft.js`的继任者，提供了更好的可扩展性和灵活性。特别的，`Lexical`还提供了`IOS`的原生支持，基于`Swift/TextKit`编写的可扩展文本编辑器，共享`Lexical`设计理念与`API`。

`Lexical`的数据结构与`Slate`类似，都是基于树形的嵌套结构来表达内容。但是其整体设计上增加了很多的预设内容，并没有像`Slate`设计为足够灵活的编辑器引擎，从下面的数据结构表达中也可以看出并没有那么简洁，这已经是精简过后的内容，原本还存在诸如`detail`等属性。

```js
[
  {
    children: [
      { format: 0, mode: "normal", text: "这样", type: "text" },
      { format: 2, mode: "normal", text: "一段文本", type: "text" },
      { format: 0, mode: "normal", text: "的", type: "text" },
      { format: 1, mode: "normal", text: "数据结构", type: "text" },
      { format: 0, mode: "normal", text: "如下所示。", type: "text" },
    ],
    direction: "ltr",
    indent: 0,
    type: "paragraph",
    version: 1,
    textFormat: 0,
  },
]
```

由于其本身是嵌套的数据结构，那么选区的表达也类似于`Slate`的实现。只不过`Lexical`的选区类似于`ProseMirror`的实现，将选区分为了`RangeSelection`、`NodeSelection`、`TableSelection`、`null`选区类型。

其中`Table`以及`null`的选区类型比较特殊，我们就暂且不论。而针对于`Range`、`Node`实际上是可以同构表达的，`Node`是针对于`Void`类型如图片、分割线的表达，而类似于`Quill`以及`Slate`是将其直接融入`Range`的表达，以零宽字符文本作为选区落点。

实际上特殊的表达自然是有特殊的含义，`Quill`以及`Slate`通过零宽字符同构了选区的文本表达，而`Lexical`的设计是不存在零宽字符占位的，所以无法直接同构文本选区表达。那么对于`Lexical`的选区，基础的文本`RangeSelection`选区如下所示:

```js
{
  anchor: { key: "51", offset: 2, type: "text" },
  focus: { key: "51", offset: 3, type: "text" }
}
```





### 飞书文档

## 选区结构设计

### Range

### State

### RawRange

## 总结

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://quilljs.com/docs/api#selection>
- <https://lexical.dev/docs/concepts/selection>
- <https://prosemirror.net/docs/ref/#state.Selection>
- <https://tiptap.dev/docs/editor/api/commands/selection>
- <https://docs.slatejs.org/concepts/03-locations#selection>
