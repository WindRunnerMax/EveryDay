# 浏览器选区模型的基本操作
先前我们提到了，数据模型的设计是编辑器的基础模块，其直接影响了选区模块的表示。选区模块的设计同样是编辑器的基础部分，编辑器应用变更时操作范围的表达，就需要基于选区模型来实现，也就是说选区代表的意义是编辑器需要感知在什么范围内执行变更命令。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

从零实现富文本编辑器项目的相关文章:

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的基本操作](./浏览器选区模型的基本操作.md)

## 浏览器选区
数据模型设计直接影响了编辑器选区模型的表达，例如下面的例子中`Quill`与`Slate`编辑器的模型选区实现，其与本身维护的数据结构密切相关。然而无论是哪种编辑器设计的数据模型，都需要基于浏览器的选区来实现，因此在本文中我们先来实现浏览器选区模型的基本操作。

```js
// Quill
{ index: 0, length: 3 }

// Slate
{ 
  anchor: { offset: 0, path: [0, 0] }, 
  focus: { offset: 3, path: [0, 0] } 
} 
```

实际上选区这个概念还是比较抽象，但是我们应该是经常与其打交道的。例如在鼠标拖动文本部分内容时，这部分会携带淡蓝色的背景色，这就是选区范围的表达，同样我们可能会将其称为选中、拖蓝、选中范围等等，这便是浏览器提供的选区能力。

除了选中文本的蓝色背景色外，闪烁的光标同样是选区的一种表现形式。光标的选区范围是一个点，或者可以称为折叠的选区。光标的表达通常只出现在可编辑元素中，例如输入框、文本域、`ContentEditable`元素等。若是在非可编辑元素中，光标处于虽然不可见状态，但实际上仍然是存在的。

浏览器选区的操作主要基于`Range`和`Selection`对象，`Range`对象表示包含节点和部分文本节点的文档片段，`Selection`对象表示用户选择的文本范围或光标符号的当前位置。

### Range
`Range`对象与数学上的区间概念类似，也就是说`Range`指的是一个连续的内容范围。数学上的区间表示由两个点即可表示，`Range`对象的表达同样是由`startContainer`起始到`endContainer`结束，因此选区必须要连续才能够正常表达。`Range`实例对象的属性如下:

- `startContainer`：表示选区的起始节点。
- `startOffset`：表示选区的起始偏移量。
- `endContainer`：表示选区的结束节点。
- `endOffset`：表示选区的结束偏移量。
- `collapsed`: 表示`Range`的起始位置和终止位置是否相同，即折叠状态。
- `commonAncestorContainer`：表示选区的共同祖先节点，即完整包含`startContainer`和`endContainer`最深一级的节点。

`Range`对象还存在诸多方法，在我们的编辑器中常用的主要是设置设置选区起始位置`setStart`、设置结束位置`setEnd`、获取选区矩形位置`getBoundingClientRect`等。在下面的例子中，我们就可以获取文本片段`23`的位置：

```html
<span id="$1">123456</span>
<script>
  const range = document.createRange();
  range.setStart($1.firstChild, 1);
  range.setEnd($1.firstChild, 3);
  console.log(range.getBoundingClientRect());
</script>
```

获取文本片段矩形位置是个非常重要的应用，这样我们可以实现非完整`DOM`元素的位置获取，而不是必须通过`HTML DOM`来获取矩形位置，这对实现诸如划词高亮等效果非常有用。此外，需要关注的是这里的`firstChild`是`Text`节点，即值为`Node.TEXT_NODE`类型，这样才可以计算文本片段。

既然可以设置文本节点，那么自然也存在非文本节点的状态。在调用设置选区时，如果节点类型是`Text`、`Comment`或`CDATASection`之一，那么`offset`指的是从结束节点算起字符的偏移量。对于其他`Node`类型节点，`offset`是指从结束结点开始算起子节点的偏移量。

在下面的例子中，我们就是将选区设置为非文本内容的节点。此时最外层的`$1`节点作为父节点，存在`2`个子节点，因此`offset`可以设置的范围是`0-2`，若此时设置为`3`则会直接抛出异常。这里基本与设置文本选区的`offset`一致，差异是文本选区必须要文本节点，非文本则是父节点。

```html
<span id="$1"><span>123</span><span>456</span></span>
<script>
  const range = document.createRange();
  range.setStart($1, 1);
  range.setEnd($1, 2);
  console.log(range.getBoundingClientRect());
</script>
```

构造`Range`对象主要的目的便是获取相关`DOM`的位置来计算，还有个常见的需求是实现内容高亮，通常来说这需要我们主动计算位置来实现虚拟图层。在较新的浏览器中实现了`::highlight`伪元素，可以帮我们用浏览器的原生实现来实现高亮效果，下面的例子中`23`文本片段就会出现背景色。

```html
<span id="$1">123456</span>
<style>
  ::highlight(highlight-bg) {
    color: white;
    background-color: blue;
  }
</style>
<script>
  const range = document.createRange();
  range.setStart($1.firstChild, 1);
  range.setEnd($1.firstChild, 3);
  const highlightBG = new Highlight();
  highlightBG.add(range);
  CSS.highlights.set("highlight-bg", highlightBG);
</script>
```

### Selection
`Selection`对象表示用户选择的文本范围或光标符号的当前位置，其代表页面中的文本选区，可能横跨多个元素。文本选区通常由用户拖拽鼠标经过文字而产生，实际上浏览器中的`Selection`就是由`Range`来组成的。`Selection`对象的主要属性如下:

- `anchorNode`：表示选区的起始节点。
- `anchorOffset`：表示选区的起始偏移量。
- `focusNode`：表示选区的结束节点。
- `focusOffset`：表示选区的结束偏移量。
- `isCollapsed`：表示选区的起始位置和终止位置是否相同，即折叠状态。
- `rangeCount`：表示选区中包含的`Range`对象的数量。

用户可能从左到右选择文本或从右到左选择文本，`anchor`指向用户开始选择的地方，而`focus`指向用户结束选择的地方。`anchor`和`focus`的概念不能与选区的起始位置`startContainer`和终止位置`endContainer`混淆，`Range`对象永远是`start`节点指向`end`节点。

- 锚点`anchor`: 选区的锚指的是选区起始点，当我们使用鼠标框选一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。
- 焦点`focus`: 选区的焦点指的是选区的终点，当我们用鼠标框选一个选区的时候，焦点是我们的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。

我们可以通过`SelectionChange`事件来监听选区的变化，在这个选区的事件回调中，可以通过`window.getSelection()`来获取当前的选区对象状态。通过`getSelection`获取的选区实例对象是个单例对象，即引用是同实例，内部的值是变化的。

当然`W3C`标准并未强制要求单例，但主流浏览器`Chrome`、`Firefox`、`Safari`实现为同一实例。不过为了保证兼容性以及`null`状态，我们实际要使用选区对象的时候，通常是实时通过`getSelection`获取选区状态。此外`Selection`对象的属性是不可枚举的，`spread`操作符是无效的。

```js
document.addEventListener("selectionchange", () => {
  const selection = window.getSelection();
  console.log({
    anchor: selection.anchorNode,
    anchorOffset: selection.anchorOffset,
    focus: selection.focusNode,
    focusOffset: selection.focusOffset,
    isCollapsed: selection.isCollapsed,
  });
});
```

编辑器中自然还需要设置选区的操作，这部分可以使用`Selection`对象的`addRange`方法来实现，通常在调用该方法之前需要使用`removeAllRanges`方法来移除已有选区。需要注意的是，该方法无法处理反向的选区，即`backward`状态。

```html
<span id="$1">123456</span>
<script>
  const range = document.createRange();
  range.setStart($1.firstChild, 1);
  range.setEnd($1.firstChild, 3);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
</script>
```

因此设置选区时，通常是需要使用`setBaseAndExtent`来实现。正向的选区直接将`start`、`end`方向的节点设置为`base`和`extent`即可，反向选区则是将`start`、`end`方向的节点设置为`extent`和`base`，这样就可以实现反向选区的效果，`DOM`节点参数与`Range`基本一致。


```html
<span id="$1">123456</span>
<script>
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 3, $1.firstChild, 1);
</script>
```

设置选区的部分可以通过上述`API`实现，而获取选区的部分虽然可以通过`focus`和`anchor`来获取。但是在`Selection`对象上并未标记`backward`状态，因此我们还需要通过`getRangeAt`方法来获取选区内建的`Range`对象，因此来对比原始对象的状态。

`Selection`对象上的`rangeCount`属性表示选区中包含的`Range`对象的数量，通常我们只需要获取第一个选区即可。这里的判断条件需要特别关注，因为若是当前没有选区值，也就是`rangeCount`为`0`，此时直接获取内建选区对象是会抛出异常的。

此外我们可能会好奇，通常进行选区操作的时候我们都是只能选单个连读的选区的，为什么会出现`rangeCount`属性。这里是需要注意在`Firefox`中是可以设置多个选区的，按住`Ctrl`键可以实现多个选区的状态，但是为了主要浏览器兼容性通常我们只需要处理首个选区。

```html
<span id="$1">123456</span>
<script>
  const selection = window.getSelection();
  selection.setBaseAndExtent($1.firstChild, 3, $1.firstChild, 1);
  if (selection.rangeCount > 0) {
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    console.log(rect);
  }
</script>
```

选区颜色 user-select: none; 


## 可编辑元素


contenteditable 跨节点 editorjs 飞书文档

BlockKit

## 自绘选区

## 总结


编辑器选区与浏览器选区的同步

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://www.w3.org/TR/selection-api/>
- <https://juejin.cn/post/7068232010304585741>
- <https://developer.mozilla.org/en-US/docs/Web/API/Range>
- <https://developer.mozilla.org/en-US/docs/Web/API/Selection>
- <https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint>
- <https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint>
- <https://developer.mozilla.org/en-US/docs/Web/API/Document/caretPositionFromPoint>
