# 基于组合事件的半受控输入模式
在先前我们实现了编辑器选区和模型选区的双向同步，来实现受控的选区操作，这是编辑器中非常重要的基础能力。接下来我们需要在编辑器选区模块的基础上，通过浏览器的组合事件来实现半受控的输入模式，在这里我们需要处理浏览器复杂`DOM`结构默认行为，还需要兼容`IME`输入法的各种输入场景。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

从零实现富文本编辑器项目的相关文章:

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)

## 编辑器输入模式
`Input`模块是处理输入的模块，输入是编辑器的核心操作之一，我们需要处理输入法、键盘、鼠标等输入操作。输入法的交互处理是需要非常多的兼容处理，例如输入法还存在候选词、联想词、快捷输入、重音等等。甚至是移动端的输入法兼容更麻烦，在`draft`中还单独列出了移动端输入法的兼容问题。

编辑器输入模块与选区模块类似，都需要在浏览器`DOM`的基础上处理其默认行为，特别是需要唤醒输入法的输入则需要更多模块的联动，因此还需要复杂的兼容性适配。而输入模式本身则分为三种类型，即非受控输入、半受控输入和受控输入，每种输入模式都有其特定的使用场景和实现方式。

### 非受控输入
非受控的方法，指的是完全依赖浏览器的默认行为来处理输入操作，而不需要对输入进行干预或修改，当`DOM`结构发生变化后需要收集变更，再应用到编辑器中。这种方式可以最大限度利用浏览器原生能力，包括选区、光标等，然而其最大的问题就是输入不受控制，无法阻止默认行为，不够稳定。

举个目前比较常见的例子，`ContentEditable`无法真正阻止`IME`的输入，这就导致了我们无法真正接管中文的输入行为。在下面的这个例子中，输入英文和数字是不会有响应的，但是中文却是可以正常输入的，这也是很多编辑器选择自绘选区和受控输入的原因之一，例如`VSCode`、钉钉文档等。

```html
<div contenteditable id="$1"></div>
<script>
  const stop = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  $1.addEventListener("beforeinput", stop);
  $1.addEventListener("input", stop);
  $1.addEventListener("keydown", stop);
  $1.addEventListener("keypress", stop);
  $1.addEventListener("keyup", stop);
  $1.addEventListener("compositionstart", stop);
  $1.addEventListener("compositionupdate", stop);
  $1.addEventListener("compositionend", stop);
</script>
```

采用非受控方法输入的时候，我们需要`MutationObserver`来确定当前正在输入字符，之后通过解析`DOM`结构得到最新的`Text Model`。紧接着需要与原来的`Text Model`做`diff`，由此来得到变更的`ops`，这样就可以应用到当前的`Model`中进行后续的工作了。

即使是非受控的输入也存在多种实现的方案，例如可以在触发`Input`事件后以行为基础做文本`diff`，得到`ops`后就可以根据`schema`组合属性。或者也可以完全依赖`MutationObserver`来得到节点级别的片段变更，在此基础上再做`diff`，著名的`quill`编辑器就是如此实现的。

`quill`针对输入的处理本身并不复杂，虽然涉及到非常多处的事件通信以及特殊`case`处理，但核心逻辑还是比较清晰的。但是我觉得有一点比较麻烦的是，`quill`封装的视图层`parchment`并不在核心包中，虽然继承重写了部分方法，但是诸如`Text`是直接导出的，很多地方还是很难调试。

整体来说，`quill`的非受控输入分为两种处理，如果普通的`ASCII`输入则直接根据`MutationRecord`的`oldValue`与最新的`newText`文本进行对比，得到变更的`ops`。若是`IME`的输入，例如中文输入的内容，则会导致多次`Mutation`，此时就会进行全量`delta`的`diff`得到变更。

```js
// https://github.com/slab/quill/blob/07b68c/packages/quill/src/core/editor.ts#L273
const oldDelta = this.delta;
if (
  mutations.length === 1 &&
  mutations[0].type === 'characterData' &&
  mutations[0].target.data.match(ASCII) 
) {
  const textBlot = this.scroll.find(mutations[0].target) as Blot;
  const index = textBlot.offset(this.scroll);
  const oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');
  const oldText = new Delta().insert(oldValue);
  const newText = new Delta().insert(textBlot.value());
  const diffDelta = new Delta()
    .retain(index)
    .concat(oldText.diff(newText, relativeSelectionInfo));
} else {
  this.delta = this.getDelta();
  if (!change || !isEqual(oldDelta.compose(change), this.delta)) {
    change = oldDelta.diff(this.delta, selectionInfo);
  }
}
```

这里需要关注的问题是，为什么`textBlot`能够得到最新的值，无论是在`MutationRecord`中还是在`getDelta`中，都是通过`textBlot.value()`来获取最新的文本内容。`getDelta`部分是迭代了一遍所有的`Bolt`来重新得到最新的`value`，这部分按行存在缓存，否则性能容易出问题。

```js
// https://github.com/slab/quill/blob/07b68c/packages/quill/src/core/editor.ts#L162
this.scroll.lines().reduce((delta, line) => {
  return delta.concat(line.delta());
}, new Delta());

// https://github.com/slab/quill/blob/07b68c/packages/quill/src/blots/block.ts#L183
function blockDelta(blot: BlockBlot, filter = true) {
  return blot
    .descendants(LeafBlot)
    .reduce((delta, leaf) => {
      if (leaf.length() === 0) {
        return delta;
      }
      return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
    }, new Delta())
    .insert('\n', bubbleFormats(blot));
}
```




### 半受控输入
半受控的方法，指的是通过`BeforeInputEvent`以及`CompositionEvent`分别处理英文输入、内容删除以及`IME`输入，以及额外的`KeyDown`、`Input`事件来辅助完成这部分工作。通过这种方式就可以劫持用户的输入，由此构造变更来应用到当前的内容模型。

当然对于类似`CompositionEvent`需要一些额外的处理，因为先前我们也提到了`IME`的输入是无法完全受控的，这也是当前主流的实现方法。当然由于浏览器的兼容性，通常会需要对`BeforeInputEvent`做兼容，例如借助`React`的合成事件或者`onKeyDown`来完成相关的兼容。


### 受控输入
全受控的方法，当我们自绘选区的时候，就必须将所有的内容进行绘制，比如`IME`输入的时候，相关的字符需要记录并且分配`id`，当结束的时候将原来的内容删除并且构造为新的`Model`，全受控通常需要一个隐藏的输入框甚至是`iframe`来完成。

这其中也有很多细节需要处理，例如在`CompositionEvent`时需要绘制内容但不能触发协同。此外如果需要实现与浏览器一致的输入体验，例如浏览器中唤醒输入法时会有拼音状态提示，这个提示不仅仅是用来展示的，若是按下左右按键是可以进行候选词切换的，全受控模式下自然也需要模拟。



## 半受控输入实现
在上述的的输入模式中，我们将重点放在半受控输入模式的实现上，因为半受控输入模式是目前大多数富文本编辑器的主流实现方式。通常来说半受控模式下能够在保证用户输入体验的同时，提供相对较好的控制和灵活性。之前聊到过输入的设计与抽象，我们可以比较简单地设计整个流程: 

- 通过选区映射到我们自行维护的`Range Model`，包括选区变换时根据`DOMRange`映射到`Model`，这一步需要比较多的查找和遍历，还需要借助我们之前聊的`WeakMap`对象来查找`Model`来计算位置。
- 通过键盘进行输入，借助于浏览器的`BeforeInputEvent`以及`CompositionEvent`分别处理输入/删除与`IME`输入，基于输入构造`Delta Change`应用到状态结构上并且触发`ContentChange`，视图层由此进行更新。
- 当视图层更新之后，需要根据浏览器的`DOM`以及我们维护的`Model`刷新模型选区，然后需要根据`Model`映射到`DOMRange`选区，再应用到浏览器的`selection`对象中，这其中也涉及了很多边界条件。


### 受控输入模式




### 非受控输入模式




## 总结

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://github.com/slab/quill/blob/539cbf/packages/quill/src/core/editor.ts#L299>
- <https://github.com/ianstormtaylor/slate/blob/ef76eb/packages/slate-react/src/components/editable.tsx#L550>
