# 基于组合事件的半受控输入模式
在先前我们实现了编辑器选区和模型选区的双向同步，来实现受控的选区操作，这是编辑器中非常重要的基础能力。接下来我们需要在编辑器选区模块的基础上，基于浏览器的组合事件来实现半受控的输入模式。在这里我们需要处理浏览器复杂`DOM`结构默认行为，还需要兼容`IME`输入法的各种输入场景。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

从零实现富文本编辑器项目的相关文章:

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)

## 编辑器输入模式
`Input`模块是处理输入的模块，输入是编辑器的核心操作之一，我们需要处理输入法、键盘、鼠标等输入操作。输入法的交互处理是需要非常多的兼容处理，例如输入法还存在候选词、联想词、快捷输入、重音等等。甚至是移动端的输入法兼容更麻烦，在`draft`中还单独列出了移动端输入法的兼容问题。

编辑器输入模块与选区模块类似，都需要在浏览器`DOM`的基础上处理其默认行为，特别是需要唤醒输入法的输入则需要更多模块的联动，因此还需要复杂的兼容性适配。而输入模式本身则分为三种类型，即非受控输入、半受控输入和受控输入，每种输入模式都有其特定的使用场景和实现方式。

### 非受控输入
非受控的方法，指的是完全依赖浏览器的默认行为来处理输入操作，而不需要对输入进行干预或修改，当`DOM`结构发生变化后需要收集变更，再应用到编辑器中。这种方式可以最大限度利用浏览器原生能力，包括选区、光标等，然而其最大的问题就是输入不受控制，无法阻止默认行为，不够稳定。

举个目前比较常见的例子，`ContentEditable`无法真正阻止`IME`的输入，这就导致了我们无法真正阻止中文的输入。在下面的这个例子中，输入英文和数字是不会有响应的，但是中文却是可以正常输入的，这也是很多编辑器选择自绘选区和受控输入的原因之一，例如`VSCode`、钉钉文档等。

```html
<div contenteditable id="$1"></div>
<script>
  const stop = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  $1.addEventListener('beforeinput', stop);
  $1.addEventListener('input', stop);
  $1.addEventListener('keydown', stop);
  $1.addEventListener('keypress', stop);
  $1.addEventListener('keyup', stop);
  $1.addEventListener('compositionstart', stop);
  $1.addEventListener('compositionupdate', stop);
  $1.addEventListener('compositionend', stop);
</script>
```

采用非受控方法输入的时候，我们需要`MutationObserver`来确定当前正在输入字符，之后通过解析`DOM`结构得到最新的`Text Model`，之后需要与原来的`Text Model`做`diff`，由此来得到`ops`，这样就可以应用到当前的`Model`中进行后续的工作了。



### 半受控输入
半受控的方法，指的是通过`BeforeInputEvent`以及`CompositionEvent`分别处理英文输入、内容删除以及`IME`输入，以及额外的`KeyDown`、`Input`事件来辅助完成这部分工作。通过这种方式就可以劫持用户的输入，由此构造变更来应用到当前的内容模型。

当然对于类似`CompositionEvent`需要一些额外的处理，因为先前我们也提到了`IME`的输入是无法完全受控的，这也是当前主流的实现方法。当然由于浏览器的兼容性，通常会需要对`BeforeInputEvent`做兼容，例如借助`React`的合成事件或者`onKeyDown`来完成相关的兼容。


### 受控输入
全受控的方法，当我们自绘选区的时候，就必须将所有的内容进行绘制，比如`IME`输入的时候，相关的字符需要记录并且分配`id`，当结束的时候将原来的内容删除并且构造为新的`Model`，全受控通常需要一个隐藏的输入框甚至是`iframe`来完成。

这其中也有很多细节需要处理，例如在`CompositionEvent`时需要绘制内容但不能触发协同。此外如果需要实现与浏览器一致的输入体验，例如浏览器中唤醒输入法时会有拼音状态提示，这个提示不仅仅是用来展示的，若是按下左右按键是可以进行候选词切换的，全受控模式下自然也需要模拟。



## 半受控输入实现
在上述的的输入模式中，我们将重点放在半受控输入模式的实现上，因为半受控输入模式是目前大多数富文本编辑器的主流实现方式。通常来说半受控模式下能够在保证用户输入体验的同时，提供相对较好的控制和灵活性。之前聊到过输入的设计与抽象，我们可以比较简单地设计整个流程: 

- 通过选区映射到我们自行维护的`Range Model`，包括选区变换时根据`DOMRange`映射到`Model`，这一步需要比较多的查找和遍历，还需要借助我们之前聊的`WeakMap`对象来查找`Model`来计算位置。
- 通过键盘进行输入，借助于浏览器的`BeforeInputEvent`以及`CompositionEvent`分别处理输入/删除与`IME`输入，基于输入构造`Delta Change`应用到状态结构上并且触发`ContentChange`，视图层由此进行更新。
- 当视图层更新之后，需要根据浏览器的`DOM`以及我们维护的`Model`刷新模型选区，然后需要根据`Model`映射到`DOMRange`选区，再应用到浏览器的`selection`对象中，这其中也涉及了很多边界条件。


### 受控输入模式




### 非受控输入模式




## 总结

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考
- <https://github.com/ianstormtaylor/slate/blob/ef76eb/packages/slate-react/src/components/editable.tsx#L550>
