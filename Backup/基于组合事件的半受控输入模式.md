# 基于组合事件的半受控输入模式
在先前我们实现了编辑器选区和模型选区的双向同步，来实现受控的选区操作，这是编辑器中非常重要的基础能力。接下来我们需要在编辑器选区模块的基础上，通过浏览器的组合事件来实现半受控的输入模式，在这里我们需要处理浏览器复杂`DOM`结构默认行为，还需要兼容`IME`输入法的各种输入场景。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

从零实现富文本编辑器项目的相关文章:

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)

## 编辑器输入模式
`Input`模块是处理输入的模块，输入是编辑器的核心操作之一，我们需要处理输入法、键盘、鼠标等输入操作。输入法的交互处理是需要非常多的兼容处理，例如输入法还存在候选词、联想词、快捷输入、重音等等。甚至是移动端的输入法兼容更麻烦，在`draft`中还单独列出了移动端输入法的兼容问题。

编辑器输入模块与选区模块类似，都需要在浏览器`DOM`的基础上处理其默认行为，特别是需要唤醒输入法的输入则需要更多模块的联动，因此还需要复杂的兼容性适配。而输入模式本身则分为三种类型，即非受控输入、半受控输入和受控输入，每种输入模式都有其特定的使用场景和实现方式。

### 非受控输入
非受控的方法，指的是完全依赖浏览器的默认行为来处理输入操作，而不需要对输入进行干预或修改，当`DOM`结构发生变化后需要收集变更，再应用到编辑器中。这种方式可以最大限度利用浏览器原生能力，包括选区、光标等，然而其最大的问题就是输入不受控制，无法阻止默认行为，不够稳定。

举个目前比较常见的例子，`ContentEditable`无法真正阻止`IME`的输入，这就导致了我们无法真正接管中文的输入行为。在下面的这个例子中，输入英文和数字是不会有响应的，但是中文却是可以正常输入的，这也是很多编辑器选择自绘选区和受控输入的原因之一，例如`VSCode`、钉钉文档等。

```html
<div contenteditable id="$1"></div>
<script>
  const stop = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  $1.addEventListener("beforeinput", stop);
  $1.addEventListener("input", stop);
  $1.addEventListener("keydown", stop);
  $1.addEventListener("keypress", stop);
  $1.addEventListener("keyup", stop);
  $1.addEventListener("compositionstart", stop);
  $1.addEventListener("compositionupdate", stop);
  $1.addEventListener("compositionend", stop);
</script>
```

采用非受控方法输入的时候，我们需要`MutationObserver`来确定当前正在输入字符，之后通过解析`DOM`结构得到最新的`Text Model`。紧接着需要与原来的`Text Model`做`diff`，由此来得到变更的`ops`，这样就可以应用到当前的`Model`中进行后续的工作了。

即使是非受控的输入也存在多种实现的方案，例如可以在触发`Input`事件后以行为基础做文本`diff`，得到`ops`后就可以根据`schema`组合属性。或者也可以完全依赖`MutationObserver`来得到节点级别的片段变更，在此基础上再做`diff`，著名的`quill`编辑器就是如此实现的。

`quill`针对输入的处理本身并不复杂，虽然涉及到非常多处的事件通信以及特殊`case`处理，但核心逻辑还是比较清晰的。但是我觉得有一点比较麻烦的是，`quill`封装的视图层`parchment`并不在核心包中，虽然继承重写了部分方法，但是诸如`Text`是直接导出的，很多地方还是很难调试。

整体来说，`quill`的非受控输入分为两种处理，如果普通的`ASCII`输入则直接根据`MutationRecord`的`oldValue`与最新的`newText`文本进行对比，得到变更的`ops`。若是`IME`的输入，例如中文输入的内容，则会导致多次`Mutation`，此时就会进行全量`delta`的`diff`得到变更。

```js
// https://github.com/slab/quill/blob/07b68c9/packages/quill/src/core/editor.ts#L273
const oldDelta = this.delta;
if (
  mutations.length === 1 &&
  mutations[0].type === 'characterData' &&
  mutations[0].target.data.match(ASCII) 
) {
  const textBlot = this.scroll.find(mutations[0].target) as Blot;
  const index = textBlot.offset(this.scroll);
  const oldValue = mutations[0].oldValue.replace(CursorBlot.CONTENTS, '');
  const oldText = new Delta().insert(oldValue);
  const newText = new Delta().insert(textBlot.value());
  const diffDelta = new Delta()
    .retain(index)
    .concat(oldText.diff(newText, relativeSelectionInfo));
} else {
  this.delta = this.getDelta();
  if (!change || !isEqual(oldDelta.compose(change), this.delta)) {
    change = oldDelta.diff(this.delta, selectionInfo);
  }
}
```

这里需要关注的问题是，为什么`textBlot`能够得到最新的值，无论是在`MutationRecord`中还是在`getDelta`中，都是通过`textBlot.value()`来获取最新的文本内容。`getDelta`部分是迭代了一遍所有的`Bolt`来重新得到最新的`value`，这部分按行存在缓存，否则性能容易出问题。

```js
// https://github.com/slab/quill/blob/07b68c9/packages/quill/src/core/editor.ts#L162
this.scroll.lines().reduce((delta, line) => {
  return delta.concat(line.delta());
}, new Delta());

// https://github.com/slab/quill/blob/07b68c9/packages/quill/src/blots/block.ts#L183
function blockDelta(blot: BlockBlot, filter = true) {
  return blot
    .descendants(LeafBlot)
    .reduce((delta, leaf) => {
      if (leaf.length() === 0) {
        return delta;
      }
      return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
    }, new Delta())
    .insert('\n', bubbleFormats(blot));
}
```

`TextBlot`就是定义在`parchment`中的实现，因此这里调试起来就比较麻烦。首先需要关注的是更新到最新的文本，我们只关注于纯文本内容更新即可，`Blot`中存在更新的方法，当`DOM`发生变化之后就会触发该方法，这里需要注意更新是从静态方法上得到的，而不是实例的`.value`。

```js
// https://github.com/slab/parchment/blob/3d0b71c/src/blot/text.ts#L80
public update(mutations: MutationRecord[], _context: { [key: string]: any }): void {
  if (
    mutations.some((mutation) => {
      return (mutation.type === 'characterData' && mutation.target === this.domNode);
    })
  ) {
    this.text = this.statics.value(this.domNode);
  }
}

public static value(domNode: Text): string {
  return domNode.data;
}
```

此外需要关注的是更新时机，也就是说调用时机必须要先更新`Blot`的内容，以此来得到最新的文本内容，最后再调度`scroll`的`update`来更新编辑器模型。我们主要关注输入的变更，这里其实还有诸如`format`引起的`DOM`结构变更，属于`optimize`方法处理`MutationRecord`部分。


```js
// https://github.com/slab/parchment/blob/3d0b71c/src/blot/scroll.ts#L205
// handleCompositionEnd - batchEnd - scrollUpdate - blotUpdate - editorUpdate
mutations
.map((mutation: MutationRecord) => {
  const blot = this.find(mutation.target, true);
  // ...
})
.forEach((blot: Blot | null) => {
  if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {
    blot.update(mutationsMap.get(blot.domNode) || [], context);
  }
});
```

这里还有个有趣的实现是在执行`diff`方法时的`cursor`参数，考虑到一个问题，文本若是从`xxx`变更到`xx`，那么就存在很多种可能。在这里可以是在任意一个位置删除一个字符，也可以是在光标处向前`forward`删除一个字符，甚至是删除两个`x`再插入一个`x`。

因此如果想比较精确地得到变更的`ops`，那就需要将光标位置传入`diff`方法中，以此可以将字符串切为三段，前缀和后缀是相同的，中间就可以作为差异部分。输入这部分是非常高频的操作，这种方式就不需要实际参与到复杂的`diff`流程当中，以更高的性能来处理文本变更。

```js
// https://github.com/jhchen/fast-diff/blob/da83236/diff.js#L1039
var newBefore = newText.slice(0, newCursor);
var newAfter = newText.slice(newCursor);
var prefixLength = Math.min(oldCursor, newCursor);
var oldPrefix = oldBefore.slice(0, prefixLength);
var newPrefix = newBefore.slice(0, prefixLength);
var oldMiddle = oldBefore.slice(prefixLength);
var newMiddle = newBefore.slice(prefixLength);
return remove_empty_tuples([
  [DIFF_EQUAL, before],
  [DIFF_DELETE, oldMiddle],
  [DIFF_INSERT, newMiddle],
  [DIFF_EQUAL, after],
]);
```

### 半受控输入
半受控的方法，指的是通过`BeforeInputEvent`以及`CompositionEvent`分别处理英文输入、内容删除以及`IME`输入，以及额外的`KeyDown`、`Input`事件来辅助完成这部分工作。通过这种方式就可以劫持用户的输入，由此构造变更来应用到当前的内容模型。

当然对于类似`CompositionEvent`需要一些额外的处理，因为先前我们也提到了`IME`的输入是无法完全受控的，因此半受控也是当前主流的实现方法。当然由于浏览器的兼容性，通常会需要对`BeforeInputEvent`做兼容，例如借助`React`的合成事件或者`onKeyDown`来完成相关的兼容。

`slate`编辑器的输入模式就是半受控的实现方式，主要是基于`beforeinput`事件以及`composition`相关事件来处理输入和删除操作。在`slate`刚开始实现的时候，`beforeinput`事件还没有被广泛支持，但是现在已经可以在大多数现代浏览器中使用了，`composition`事件则早已广泛支持。

首先来看受控的部分，我们的受控特指可以阻止默认的输入行为，而我们可以根据相关事件主动更新编辑器模型。在输入这个场景我们主要关注`insert`相关的`inputType`即可，只不过输入上还有大量的模式需要处理，此外`slate`还存在大量兼容性逻辑来处理各种浏览器的实现问题。

```js
// https://github.com/ianstormtaylor/slate/blob/ef76eb4/packages/slate-react/src/components/editable.tsx#L550
switch (event.inputType) {
  case 'insertFromComposition':
  case 'insertFromDrop':
  case 'insertFromPaste':
  case 'insertFromYank':
  case 'insertReplacementText':
  case 'insertText': {
    if (typeof data === 'string') {
      Editor.insertText(editor, data)
    }
  }
}
```

从上面的示例中可以看出，`inputType`本身存在大量的操作类型分支需要处理，而本身除了输入、删除之外，还存在诸如格式化、历史记录等操作类型。不过在这里我们还是主要关注输入、删除相关的操作，下面是比较常见可能需要处理的`inputType`类型:

- `insertText`: 插入文本，通常是通过键盘输入。
- `insertReplacementText`: 替换当前选区或单词的文本，例如通过拼写校正或自动完成。
- `insertLineBreak`: 插入换行符，通常是按下回车键。
- `insertParagraph`: 插入一个段落分隔符，通常存在于`ContentEditable`元素中按回车键。
- `insertFromDrop`: 通过拖拽操作插入内容。
- `insertFromPaste`: 通过粘贴操作插入内容。
- `insertTranspose`: 调换两个字符的位置，常见于`MacOS`的`Ctrl+T`操作。
- `insertCompositionText`: 插入输入法`IME`中的组合文本。
- `deleteWordBackward`: 向后删除一个单词，例如`Option+Backspace`。
- `deleteWordForward`: 向前删除一个单词，例如`Option+Delete`。
- `deleteSoftLineBackward`: 向后删除一行，当换行是自动换行时。
- `deleteSoftLineForward`: 向前删除一行，当换行是自动换行时。
- `deleteEntireSoftLine`: 删除当前所在的整个软换行。
- `deleteHardLineBackward`: 向后删除一行，当换行是硬回车时。
- `deleteHardLineForward`: 向前删除一行，当换行是硬回车时。
- `deleteByDrag`: 通过拖拽的方式删除内容。
- `deleteByCut`: 通过剪切操作删除内容。
- `deleteContent`: 向前删除内容，即`Delete`键。
- `deleteContentBackward`: 向后删除内容，即`Backspace`键。

实际上这些事件我们很难全部关注到，特别是软回车相关的内容在浏览器实现的编辑器中应用不多，因此这部分我们可以直接将其认为是硬回车来操作。在`quill`和`slate`中都是作为硬回车处理的，而`TinyMCE`、`TipTap`都有软回车的实现，即`Shift+Enter`会插入`<br>`而非创建新段落。

事件中相关的信息传递需要关注，例如`deleteWord`是需要删除词级别的内容的，这部分数据范围是通过`getTargetRanges`得到`StaticRange`数组传递。此外，诸如`insertCompositionText`、`insertFromPaste`也都是可以在`Composition`事件、`Paste`事件中来实际处理。

```js
// [StaticRange]
[{
  collapsed: false,
  endContainer: text,
  endOffset: 4,
  startContainer: text,
  startOffset: 2
}]
```

接下来我们可以关注`slate`中非受控部分，这也就是由于无法真正接管`IME`输入而导致的必须要兼容的问题。`slate`中这部分兼容起来也有点复杂，在不同浏览器中的表现还不一致，例如在`safari`中存在`insertFromComposition`的类型，都是需要在类似的时机修正编辑器模型。

除了无法阻止默认行为外，非受控的表现还体现在对于`DOM`结构的修改，这部分甚至于可以说是最难以处理的，因为只要唤醒了`IME`就意味着必然会修改`DOM`。那么就相当于这部分`DOM`是处于未知状态的，若是出现了不可预知的`DOM`内容，则意味着编辑器模型同步状态被破坏，这就需要额外兼容。

```js
// https://github.com/ianstormtaylor/slate/blob/ef76eb4/packages/slate-react/src/components/editable.tsx#L1299
// COMPAT: In Chrome, `beforeinput` events for compositions
// aren't correct and never fire the "insertFromComposition"
// type that we need. So instead, insert whenever a composition
// ends since it will already have been committed to the DOM.
if (
  !IS_WEBKIT &&
  !IS_FIREFOX_LEGACY &&
  !IS_IOS &&
  !IS_WECHATBROWSER &&
  !IS_UC_MOBILE &&
  event.data
) {
  Editor.insertText(editor, event.data)
}
```

### 受控输入
全受控的方法，指的是当执行任意内容输入的时候，输入的字符需要记录，当输入结束的时候将原来的内容删除，并且构造为新的`Model`。全受控通常需要一个隐藏的输入框甚至是`iframe`来完成，由于浏览器页面上必须保持单一焦点，因此这种方式还需要伴随着自绘选区的实现。

这其中也有很多细节需要处理，例如在`CompositionEvent`时需要绘制内容但不能触发协同。此外如果需要实现与浏览器一致的输入体验，例如浏览器中唤醒输入法时会有拼音状态提示，这个提示不仅仅是用来展示的，若是按下左右按键是可以进行候选词切换的，全受控模式下自然也需要模拟。

以受控模式实现的编辑器中，我们可以针对浏览器`API`的依赖程度来分为三类，浏览器依赖程度由高到低，也就意味着实现的难度由低到高。三种类型分别是依赖`iframe`焦点魔法以及`Editable`的类型、不依赖`Editable`而依赖`DOM`实现自绘选区的类型、完全基于`Canvas`绘制的类型。

这三种类型我们分别可以找到典型的编辑器实现，依赖`iframe`魔法的`TextBus`等，自绘选区的钉钉文档、`Zoom`文档等，以及完全基于`Canvas`绘制的腾讯文档、`Google Doc`等。实际上开源的编辑器中比较少实现受控的输入模式，因为本身实现起来比较复杂，且需要大量的兼容性处理。

接下来我们分别来看一下这三种类型，首先需要聊到的就是`iframe`魔法的实现方式，这里就不得不提到浏览器焦点问题。在浏览器中，文本内容的选中效果是会将焦点放在选中的文本上的，而此时若是鼠标点击到其他输入框就会导致焦点转移，可以通过`document.activeElement`来查看当前焦点。

```html
<div tabindex="-1">选中文本后，点击 input 可以观察焦点转移</div>
<input />
<script>
  document.onselectionchange = () => {
    console.log("Focused Element", document.activeElement);
  };
</script>
```

至于什么样子的元素可以获得焦点，这个同样是存在一定的规范的，诸如可编辑元素、`tabindex`属性、`a`标签等等，我们就不过多叙述了。那么这里的问题就在于，若是我们放置独立的`input`来接收输入，而不是直接依赖`Editable`输入的话，就会出现浏览器选区的转移问题，导致无法选中文本。




## 半受控输入实现
在上述的的输入模式中，我们将重点放在半受控输入模式的实现上，因为半受控输入模式是目前大多数富文本编辑器的主流实现方式。通常来说半受控模式下能够在保证用户输入体验的同时，提供相对较好的控制和灵活性。之前聊到过输入的设计与抽象，我们可以比较简单地设计整个流程: 

- 通过选区映射到我们自行维护的`Range Model`，包括选区变换时根据`DOMRange`映射到`Model`，这一步需要比较多的查找和遍历，还需要借助我们之前聊的`WeakMap`对象来查找`Model`来计算位置。
- 通过键盘进行输入，借助于浏览器的`BeforeInputEvent`以及`CompositionEvent`分别处理输入/删除与`IME`输入，基于输入构造`Delta Change`应用到状态结构上并且触发`ContentChange`，视图层由此进行更新。
- 当视图层更新之后，需要根据浏览器的`DOM`以及我们维护的`Model`刷新模型选区，然后需要根据`Model`映射到`DOMRange`选区，再应用到浏览器的`selection`对象中，这其中也涉及了很多边界条件。


### 受控输入模式




### 非受控输入模式




## 总结
浏览器输入模式的DOM结构兼容

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://w3c.github.io/input-events/#interface-InputEvent-Attributes>
- <https://github.com/slab/quill/blob/539cbff/packages/quill/src/core/editor.ts#L299>
- <https://github.com/ianstormtaylor/slate/blob/ef76eb4/packages/slate-react/src/components/editable.tsx#L550>