# 编辑器文本结构变更的受控处理
先前我们主要处理了浏览器复杂`DOM`结构的默认行为，以及兼容`IME`输入法的各种输入场景，以此需要针对性地处理输入法和浏览器兼容的行为。在这里我们关注于处理文本结构性变更行为的处理，主要是针对行级别的操作、文本拖拽操作等，分别处于文本结构结构以及变更操作扩展。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

<details>
<summary><strong>从零实现富文本编辑器系列文章</strong></summary>

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)
- [从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为](./浏览器输入模式的非受控DOM行为.md)
- [从零实现富文本编辑器#9-编辑器文本结构变更的受控处理](./编辑器文本结构变更的受控处理.md)

</details>

## 概述
在当前我们主要聊的编辑器输入模式中，主要是关注于文本的半受控输入以及脏`DOM`的检测，输入状态同步是比较复杂且容易出问题的地方。而在这里我们则关注于输入同步行为扩展，例如回车、删除、拖拽文本等操作，相当于完善了编辑器整体输入模式的处理。

具体来说，执行换行和删除回车时会变更`DOM`结构，而删除文本以及拖拽文本同样是由`BeforeInput`等事件组合执行的，在编辑器中这些操作都是输入的一部分。此外，这些操作通常都是可以受控处理的，因此并不太容易出现脏`DOM`的问题，但是整体上还是有很多需要注意的点:

- 回车操作通常需要拆分当前行结构，并且还需要关注到行格式的继承问题，特别是类似于列表等结构处理起来会更复杂一些。此外由于数据结构本身的设计不同，回车的操作实现也会有很大的差异，还有诸如软回车、硬回车等不同的回车类型。
- 删除操作同样会涉及行结构的处理，即删除回车时需要合并行结构，并且也会受到数据结构本身的影响，删除可能并不会符合操作直觉，因此需要手动校正行格式。并且删除的时候还需要关注`Unicode`字符的处理，特别是类似于`Emoji`等符号的删除需要特殊处理。
- 拖拽操作同样会涉及行结构的处理，而在我们的状态管理中本就是以行为单位进行管理的，因此拖拽行级结构相对会简单，当然实现的交互上还是有些工作量。而文本节点本身同样是可以拖拽的，因此我们同样需要根据选区范围进行文本的剪切和插入。

## 回车操作
在最开始的时候，我们就聊到了`ContentEditable`的不受控行为，特别是回车操作在不同浏览器中的表现是不一致的。在之前的例子中，我们就提到了回车操作在不同浏览器中的表现差异:

- 在空`contenteditable`编辑器的情况下，直接按下回车键，在`Chrome`中的表现是会插入`<div><br></div>`，而在`FireFox(<60)`中的表现是会插入`<br>`，`IE`中的表现是会插入`<p><br></p>`。
- 在有文本的编辑器中，如果在文本中间插入回车例如`123|123`，在`Chrome`中的表现内容是`123<div>123</div>`，而在`FireFox`中的表现则是会将内容格式化为`<div>123</div><div>123</div>`。
- 同样在有文本的编辑器中，如果在文本中间插入回车后再删除回车，例如`123|123->123123`，在`Chrome`中的表现内容会恢复原本的`123123`，而在`FireFox`中的表现则是会变为`<div>123123</div>`。

其实这些示例其实也写过很多次了，每次提到浏览器的不受控行为都会提到相关的差异，这些默认行为也变成了我们处理状态同步时需要关注的点。而实际上，关于回车的行为本身我们是可以受控处理的，即阻止其默认行为，然后根据当前的选区状态进行行结构的拆分和格式继承等处理。

通常来说，我们可以通过两种方式阻止默认行为，一种是监听`BeforeInput`事件并阻止其默认行为，另一种是监听`KeyDown`事件并阻止其默认行为。前者的好处是可以直接获取到事件的输入类型，例如软硬回车等，而后者的好处则是可以更早地阻止默认行为。

那么自然的我们还是借助`BeforeInput`事件来处理回车操作，这样会比较方便一些。那么这里的实现就比较简单，理论上来说我们只需要在数据结构中插入一个`\n`的`op`即可。此外由于我们的编辑器本身不支持软回车，因此这两种类型的回车都需要统一处理为硬回车。

```js
switch (inputType) {
  case "insertLineBreak":
  case "insertParagraph": {
    this.editor.perform.insertBreak(sel);
    break;
  }
}

export class Perform {
  public insertBreak(sel: Range, attributes?: AttributeMap) {
    const raw = RawRange.fromRange(this.editor, sel);
    const start = raw.start;
    const len = raw.len;
    const delta = new Delta().retain(start);
    len && delta.delete(len);
    delta.insertEOL();
    this.editor.state.apply(delta, { range: raw });
  }
}
```

这件事看起来并没有那么复杂，因为`DOM`的结构变更处理是由我们的`LineState`以及`Mutate`模块实现的，`Mutate`模块实现了`key`值的维护以及`immutable`。接下来，在`React`适配器中，我们就可以直接以`LineState`为基准渲染行结构，渲染这件事就自然而然地交给了`React`。

```js
/**
 * 数据同步变更, 异步批量绘制变更
 */
const onContentChange = useMemoFn(() => {
    setLines(state.getLines());
});

/**
 * 监听内容变更事件, 更新当前块视图
 */
useLayoutEffect(() => {
  editor.event.on(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);
  return () => {
    editor.event.off(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);
  };
}, [editor.event, onContentChange]);
```

`Mutate`模块实现的算法会比较复杂，这里就暂时先不展开了。简单来说，就是会根据当前的选区位置，找到对应的行结构，然后将其拆分为两行，并且继承当前行的格式属性。当然我们并不是`Case By Case`地处理，而是根据变更的`Delta`操作实现一个通用的变更模式。

看起来插入回车这件事就简单的结束了，然而实际上并没有，这件事复杂的点在于行格式的继承问题。那么在具体聊我们编辑器插入节点的实现之前，我们先来看一下粘贴这件事的行为，为什么突然转向聊粘贴了呢，主要是这个场景会更加的典型。

具体表现是，假如此时复制了列表的多行内容，然后将其粘贴到空行时，单论文本上是没有什么问题的。然而在多行格式上的表现是，粘贴首行的格式是列表首行格式，末尾行的内容则是普通文本格式，下面的例子中`{caret}`表示的是当前的选区光标。

```js
// 剪贴板内容
[ { insert: "123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" } ]

// 原始内容
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]

// 粘贴后内容
[ { insert: "abc123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

这个表现的根本原因是，我们的行属性是在末尾标记的，而不是在行首标记的，因此看起来表现是我们会把原始行格式挤到后边去。因此看起来非常合理的样子，而在`Quill`编辑器的表现中则是看起来是剪贴板中末尾多了个`\n`标记，即使选区复制时并未选到末尾。

```js
// 剪贴板内容
[ { insert: "123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" }, { insert: "\n", attributes: { list: "bullet" } } ]

// 原始内容
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]

// 粘贴后内容
[ { insert: "abc123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

当然在这里的表现是由于`Quill`的实现是复制时必然序列化`HTML`内容，而且并不会像我们的编辑器一样将`ops`的`fragment`写入剪贴板中。因此看起来这个数据结构像是在末尾补充了行格式，而如果是复制的是单行内容则在剪贴板中并不会有这个表现。

同样是扁平的数据格式，在`EtherPad`中的表现其实也是类似的，剪贴板的实现也是基于`HTML`序列化反序列化的实现，但是细节上的实现是剪贴板的首尾都会是携带`\n`的换行表现。其实这个表现是因为`EtherPad`的实现是将行格式放于行首的，可以转换成类似`delta`的数据结构。

```js
[ 
  { insert: "*", attributes: { list: "bullet", lmkr: "true" } }, { insert: "123" }, { insert: "\n" },
  { insert: "*", attributes: { list: "bullet", lmkr: "true" } }, { insert: "789" }, { insert: "\n" }
]
```

这里就需要思考为什么`EtherPad`控制行格式的实现是放在行首，而不是将行格式应用到`\n`上，毕竟这种情况下还需要额外处理很多问题。其实这里很多表现是与渲染相关的，因为无论是列表、引用等行格式的`DOM`渲染都是在行首的，这样看起来行首放置额外的节点来表现是更加符合操作直觉。

实际上如果额外放置了这个节点，是需要很多额外逻辑处理的，因为行格式本质上是需要和行节点一致控制的，那么就会出现节点不匹配/不一致的问题。此外，此时的行节点文本也会因为出现额外的节点，导致需要判断是否存在该节点来处理`offset`以及文本内容的计算问题。

```js
// 正常情况
[ { insert: "*", attributes: { lmkr: "true" } }, /* ... */, { insert: "\n" } ]
// 需要在应用变更时处理的情况
[ { insert: "*", attributes: { lmkr: "true" } }, { insert: "*", attributes: { lmkr: "true" } } ]
[ { insert: "text" }, { insert: "*", attributes: { lmkr: "true" } } ]
```

那么回到插入回车这件事上，在行格式的继承上，如果接着上述的操作实现，则很容易地可以看出来行格式的继承问题。在下面的例子中，`quota`表示引用格式，如果在`Md`中引用是以`>`在行首表示的，插入回车时原始行应该保持引用格式，而下面的例子中引用格式却仅表现在了新行。

```js
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]
// 插入回车后 =>
[ { insert: "abc" }, { insert: "\n" }, { insert: "{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

因此我们需要为格式的变成实现一些特殊的处理逻辑，如果光标在行首时，需要将这个行属性直接移动到新行上。如果光标在行尾，则将行属性保留在当前行。如果光标在行中间，则将行属性保留在当前行，并且新行合并当前行的属性，到这里我们基本就可以实现插入回车的相关逻辑了。

```js
// 当光标在行首时, 直接移动行属性
// |xx(\n {y:1}) => (\n)|xx(\n {y:1} & attributes)
if (start === startLine.start) {
  delta.insertEOL();
  const lineOffset = endLine.length - 1;
  delta.retain(lineOffset - sel.end.offset).retain(1, attributes);
  point = new Point(sel.start.line + 1, 0);
  // 当光标在行尾时, 将行属性保留在当前行
  // xx|(\n {y:1}) => xx(\n {y:1})(\n attributes)
} else if (start === startLine.start + startLine.length - 1) {
  delta.retain(1).insertEOL(attributes);
  point = new Point(sel.start.line + 1, 0);
  // 当光标在行中时, 将行属性保留在当前行, 下一行合并新属性
  // x|x(\n {y:1}) => xx(\n {y:1})(\n {y:1} & attributes)
} else {
  delta.insertEOL(startLine.attributes);
  const lineOffset = endLine.length - 1;
  const attrs = { ...startLine.attributes, ...attributes };
  delta.retain(lineOffset - sel.end.offset).retain(1, attrs);
}
```

## 删除操作
删除操作同样是文本结构变更中比较重要的一个操作，而同样的删除也需要关注行结构的合并以及行格式的问题。首先聊的是相对简单的部分，删除文本片段内容，由于本身我们的选区是携带`Range`信息的，因此删除文本片段内容其实并没有什么复杂的地方，直接根据选区删除对应的内容即可。

```js
export class Perform {
  public deleteFragment(sel: Range) {
    if (sel.isCollapsed) return void 0;
    const raw = RawRange.fromRange(this.editor, sel);
    if (!raw) return void 0;
    const len = Math.max(raw.len, 0);
    const start = Math.max(raw.start, 0);
    if (start < 0 || len <= 0) return void 0;
    const delta = new Delta().retain(start).delete(len);
    this.editor.state.apply(delta, { range: raw });
    return void 0;
  }
}
```

而删除本身还存在向前删除和向后删除的情况，因此我们需要分别处理`deleteContentBackward`和`deleteContentForward`两种输入类型。实际上这两种删除的实现是类似的，主要是计算删除的位置不同而已，但是也需要分别处理行首行末等情况。

处理`backward`删除时主要是处理行首删除的情况，即处于当前行的行首, 且存在行状态节点。此时分别处理上个节点为块节点、当前行存在行属性、当前行不存在行属性三种情况，这里的主要目标是删除时要删除当前行结构，以此更加符合操作直觉，并且将光标移动到合适的位置。

```js
// 处于当前行的行首, 且存在行状态节点
if (line && sel.start.offset === 0) {
  const prevLine = line && line.prev();
  // 上一行为块节点且处于当前行首时, 删除则移动光标到该节点上
  if (prevLine && isBlockLine(prevLine)) {
  // 当前行为空时特殊处理, 先删除掉该行
    if (isEmptyLine(line)) {
      const delta = new Delta().retain(line.start).delete(1);
      this.editor.state.apply(delta, { autoCaret: false });
    }
    const firstLeaf = prevLine.getFirstLeaf();
    const range = firstLeaf && firstLeaf.toRange();
    range && this.editor.selection.set(range, true);
    return void 0;
  }
  const attrsLength = Object.keys(line.attributes).length;
  // 如果在当前行的行首, 且存在其他行属性, 则删除当前行的行属性
  if (attrsLength > 0) {
    const delta = new Delta().retain(line.start + line.length - 1).retain(1, invertAttributes(line.attributes));
    this.editor.state.apply(delta, { autoCaret: false });
    return void 0;
  }
  // 如果在当前行的行首, 且不存在其他行属性, 则将当前行属性移到下一行
  if (prevLine && !attrsLength) {
    const prevAttrs = { ...prevLine.attributes };
    const delta = new Delta().retain(line.start - 1).delete(1).retain(line.length - 1).retain(1, prevAttrs);
    this.editor.state.apply(delta);
    return void 0;
  }
}
```

而处理`forward`删除时主要是处理行末删除的情况，这个情况相对起来会更简单一些，此时并没处理复杂情况，因为其操作更不高频。如果此时光标位于块节点上，那么删除时直接执行当前块节点的删除操作即可。如果光标位于当前行的行末，且下一行为块节点，那么删除时则将光标移动到该块节点上。

```js
// 当前行为块结构时, 执行 backward 删除操作
if (line && sel.start.offset === 1 && isBlockLine(line)) { 
  this.deleteBackward(sel);
  return void 0;
}
const nextLine = line && line.next();
// 下一行为块节点且处于当前行末时, 删除则移动光标到该节点上
if (line && sel.start.offset === line.length - 1 && nextLine && isBlockLine(nextLine)) {
  const firstLeaf = nextLine.getFirstLeaf();
  const range = firstLeaf && firstLeaf.toRange();
  range && this.editor.selection.set(range, true);
  return void 0;
}
```

在删除内容这里最需要关注的其实是视图层问题，当与`React`结合的视图层面更新时，同样也会出现非受控行为的问题，这里的不受控是`React`数据层及其渲染层的问题。其实，这里本质上还是跟`IME`输入的`DOM`变更有关。

具体来说，当选区存在跨节点行为时，无论是行内还是跨行的选区，唤醒输入法`Composing`输入内容后，这部分节点内容会被删除，并且替换为输入的内容。但是当确定内容之后，编辑器便会崩溃，这也是删除与插入的合并操作造成的问题，报错内容如下:

```
Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.
```

从报错上来看，`React`会将子节点从父节点移除，这本身是非常合理的行为。举个例子，当实现一个列表时，如果数据源删除了某些节点，那么`React`就会将对应的`DOM`节点自动移除掉，也就是不需要操作`DOM`，而是可以直接通过声明式的方式来实现变更。

那么这里的问题就出现在这些`DOM`已经实际上被移除了，因此当`React`尝试移除这些节点时就会报错，而这个异常会导致整个编辑器崩溃，因此我们就需要避免这个情况的发生。那么首先就需要避免`removeChild`的异常，我们很难直接避免`React`的行为，因此只能在`DOM`节点上进行拦截。

然而，即使是在`DOM`上处理拦截行为也并不容易，`removeChild`方法是在`Node`对象上的，如果我们直接重写`Node.prototype.removeChild`方法，那么就会影响到整个页面的`DOM`节点，因此我们只能尝试在编辑器的`ref`上处理。

```js
/**
 * 重写 removeChild 方法
 * - 避免 IME 破坏跨节点渲染造成问题
 * - https://github.com/facebookarchive/draft-js/issues/1320
 */
export const rewriteRemoveChild = (node: Node) => {
  const removeChild = Node.prototype.removeChild;
  node.removeChild = function <T extends Node>(child: T) {
    if (child.parentNode !== this) return child;
    return removeChild.call(this, child) as T;
  };
};
```

然而编辑器本身会存在大量的`DOM`节点，我们很难在所有的节点上进行重写，因此我们还需要限制`DOM`变动的范围。在`React`中控制重渲染的方式可以通过`key`来实现，因此就需要在`IME`输入起始时刷新相关节点的`key`，以此来避免`React`复用这些节点，然后刷新范围就限制在了行节点上。

```js
/**
 * 组合输入开始
 * @param event
 */
@Bind
protected onCompositionStart() {
  // 需要强制刷新 state.key, 且需要配合 removeChild 避免抛出异常
  const sel = this.editor.selection.get();
  if (!sel || sel.isCollapsed) return void 0;
  for (let i = sel.start.line; i <= sel.end.line; ++i) {
    const line = this.editor.state.block.getLine(i);
    line && line.forceRefresh();
  }
}
```

然后在`React`控制节点的部分，就需要将重写的逻辑加入到块节点以及行节点的`DOM`上，以此来避免异常的发生。这里还需要避免`ref`函数的重复执行，`React`的特性是如果`ref`引用不同就会原始的引用再调用新的方法，因此这里需要借助`useMemoFn`实现。

```js
const setModel = useMemoFn((ref: HTMLDivElement | null) => {
  if (ref) {
    rewriteRemoveChild(ref);
  }
});
```

从本质上来看，是执行输入法时没有办法控制`DOM`的变更行为，或者阻止浏览器的默认行为。但是我们却可以在`start`的时候就执行相关的处理，类似于将`end`时的删除且插入的行为分离出来，也就是说先执行`deleteFragment`方法，将所有的`DOM`直接通过先移除掉来同步行为。

但是这里又出现了新的问题，因为本身的`delete`方法会将选区内的内容全部删除，这样的话会导致唤醒`IME`时，选区所在的`DOM`节点会被删除。因此浏览器会将光标兜底到当前行的起始位置，虽然不影响最终输入的内容，但是在输入的时候就可以明显地看出来问题，有些影响用户体验。

在这里其实还可以考虑一种实现，在组合输入时同样会删除选区的内容，但是保留光标所在的`DOM`节点，这个实现就会很复杂。其实如果能在唤醒输入法前就将选区删除并且再设置好光标位置，再出现输入法的话，倒是就不会出现这个问题，然而目前并没有相关的`API`可以实现这样的行为。

但是在后期研究`slate`的实现发现，其仅仅是在`IME`组合输入开始的时候删除了相关的节点，而我们的编辑器却无法做到。经过排查之后发现是更新内容后的浏览器选区事件被我们阻止了，但是这里的表现也比较奇怪，阻止了选区更新竟然会导致行的该节点后的所有节点都无法渲染出来。

```js
export class Input {
  @Bind
  protected onCompositionStart() {
    // 避免 IME 破坏跨节点渲染造成问题
    const sel = this.editor.selection.get();
    if (!sel || sel.isCollapsed) return void 0;
    this.editor.perform.deleteFragment(sel);
  }
}
```

因此在这里放行选区更新的事件，即在`Update Effect`时不再通过`Composing`状态阻止选区的更新行为，这样就可以避免上述的问题了。然而这里的表现确实是非常奇怪的，`React`确实是持有了`DOM`状态，而改动就是这里的更新选区行为，选区本身导致节点无法正常渲染实在是有点费解。

```js
useLayoutEffect(() => {
  const selection = editor.selection.get();
  // 渲染完成后更新浏览器选区
  if (editor.state.isFocused() && selection) {
    editor.logger.debug("UpdateDOMSelection");
    editor.selection.updateDOMSelection(true);
  }
});
```

### Emoji 处理
`Unicode`可以视为`Map`，可以从数值`code point`映射到具体的字形，这样就可以直接引用符号而不需要实际使用符号本身。可能的代码点值范围是从`U+0000`到`U+10FFFF`，有超过`110`万个可能的符号，为了保持条理性，`Unicode`将此代码点范围划分为`17`个平面。

首个平面`U+0000 -> U+FFFF`称为基本多语言平面或`BMP`，包含了最常用的字符。这样`BMP`之外就剩下大约`100`万个代码点`U+010000 -> U+10FFFF`，这些代码点所属的平面称为补充平面或星面。

`JavaScript`的单个字符由无符号的`16`位整数支持，因此其无法容纳任何高于`U+FFFF`的代码点，而是需要将其拆分为代理对。这其实就是`JS`的`UCS-2`编码形式，造成了所有字符在`JS`中都是`2`个字节，而如果是`4`个字节的字符，那么就会当作两个双字节的字符处理即代理对。

其实这么说起来`UTF-8`的变长`1-4`字节的编码是无法表示的，代理对自然是可以解决这个问题。而表达`UTF-16`的编码长度要么是`2`个字节，要么是`4`个字节。在`ECMAScript 6`中引入了新的表达方式，但是为了向后兼容`ECMAScript 5`依然可以用代理对的形式表示星面。

```js
"\u{1F3A8}"
// 🎨
"\uD83C\uDFA8"
// 🎨
```

实际上在`ES6`中引入的函数也解决了字符串遍历的问题，正则表达式也提供了`u`修饰符来处理`4`字节的字符。

```js
Array.from("1🎨1")
// ["1", "🎨", "1"]
/^.$/u.test("🎨")
// true
"1🎨1".split("")
// ["1", "\uD83C", "\uDFA8", "1"]
```

另外在基本平面即低位代理对内，从`U+D800`到`U+DFFF`是一个空段，即这些码点不对应任何字符，自然可以避免原本基本平面的冲突，因此可以用来映射辅助平面的字符。高位`[\uD800-\uDBFF]`与低位`[\uDC00-\uDFFF]`恰好是`2^10 * 2^10`长度，恰好`100`多万个代码点。

```js
(0xDBFF - 0xD800 + 1) * (0xDFFF - 0xDC00 + 1) = 1024 * 1024 = 1048576
```

虽然可以已经用`Unicode`代理对的方式表达`4`字节符号，但是类似`Emoji`这些符号是可以组合的。那么这样会导致字形上看起来是单个字符，实际上是通过`\u200d`即`ZWJ`组合起来的字符，因此其长度会更长，且`ES6`的函数也是会将其拆离表现的。

```js
"🧑" + "\u200d" + "🎨"
// 🧑‍🎨
"🧑‍🎨".length
// 5
Array.from("🧑‍🎨")
// ["🧑", "‍", "🎨"]
```

因此，在这里我们需要在删除之前判断即将要删除的文本长度，这本身其实是可以有多种方式来实现的。例如我们即将要提到的词级别的内容删除，将其转换为非受控的状态来删除，而在这里我们则是通过计算末尾的`Unicode`字符长度来实现删除。

```js
/**
 * 获取末尾 Unicode 字符长度
 * @param str
 */
export const getLastUnicodeLen = (str: string | P.Nil) => {
  if (!str || str.length < 2) {
    return str ? str.length : 0;
  }
  const first = str.charCodeAt(str.length - 2);
  const second = str.charCodeAt(str.length - 1);
  if (0xd800 < first && first < 0xdbff && 0xdc00 < second && second < 0xdfff) {
    // 此时基本 Unicode 字符长度为 2
    let len = 2;
    // 通过连接符号来组合单个 Unicode 字符长度
    // [-][-] \u200d [-][-] \u200d [-][-]
    for (let i = str.length - 3; i > 0; i = i - 3) {
      if (str[i].charCodeAt(0) !== 0x200d) break;
      len = len + 3;
    }
    return len;
  }
  return 1;
};
```

### 词级文本处理
先前我们针对`Emoji`的删除做了特殊处理，因为其本身是多个字符组成的内容，所以在删除时如果直接取长度为`1`的话会导致出现遗留不可见字符的情况。那么除了`Emoji`可能存在删除多个字符的情况，使用`Alt + Del`组合键在默认情况下是删除词级别内容，同样是存在多个字符的情况。

如果仅仅是使用`ContentEditable`的情况下，浏览器会自动处理词级别的删除行为，包括`Emoji`的删除行为也是可以自动处理的。因此针对非受控输入的编辑器例如`Quill`、飞书文档的实现，是不太需要主动处理相关行为的，主要关注点在于`DOM`变更后的被动同步状态。

而在我们实现的编辑器中，因为输入的相关实现是完全基于`beforeInput`事件来处理的，是完全受控的行为，因此我们必须要主动处理删除的行为。实际上在事件中，`inputType`值是给出了`deleteWordBackward`和`deleteWordForward`的，却没有给出默认行为要删除的长度。

因此我最开始是想要么改为非受控输入，要么是通过`Intl.Segmenter`方法来主动分词实现。然而在看到`MDN`的`DEMO`之后，发现这个构造器需要传递语言参数，这样的话在编辑器中是没有办法实现的，因为编辑器中无法实际确定语言类型。

```js
const segmenterZH = new Intl.Segmenter("ZH-CN", { granularity: "word" });
const string1 = "当前所有功能都是基于插件化定义实现";
const iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();
console.log(iterator1.next().value.segment); // 当前
```

因此我去找了相关开源编辑器的实现，`slate`是完全自定义处理的行为，使用`getWordDistance`来自行计算词的距离。这样对于英文问题不大，但是对于中文词组的处理就比较差了，是以标点符号为准作为切割目标的，因此对于中文实现更像是按句删除了。

而在`Lexical`中尝试了删除词组的表现则比较符合预期，本来我以为也是非受控的输入，但是查阅源码后发现同样是基于`beforeInput`事件来处理的。那么这个表现就非常符合浏览器的行为，本来我以为也是基于`Segmenter`实现，想查看是如何处理语言问题的，发现首参数是可以不传递的。

```js
const segmenterZH = new Intl.Segmenter(undefined, { granularity: "word" });
const string1 = "当前所有功能都是基于插件化定义实现";
const iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();
console.log(iterator1.next().value.segment); // 当前
```

然而，再细致地查阅源码后发现，`Lexical`并未直接使用`Segmenter`来处理分词，而是使用了`selection.modify`这个`API`来预处理选区的变更。基于这个`API`可以同步地变更选区的`DOM`引用，然后我们就可以立即得到未来的选区状态，因此就可以构造删除的范围。

```js
const root = this.editor.getContainer();
const domSelection = getRootSelection(root);
const selection = this.current;
if (!domSelection || !selection) return null;
domSelection.modify(ALERT.MOVE, direction, granularity);
const staticSel = getStaticSelection(domSelection);
if (!staticSel || this.limit()) return null;
const { startContainer } = staticSel;
if (!root.contains(startContainer)) return null;
const newRange = toModelRange(this.editor, staticSel, false);
newRange && this.set(newRange);
```

并且在`Lexical`中还解释了`beforeInput`事件以及对应的`getTargetRanges()`方法。由此先前我对于浏览器没有给出默认要删除的长度的判断是错误的，其是通过`Range`来表达的。但是注释中还提到了这个方案不可靠，其在复杂场景下可能无法正确反应操作后的选区状态。

而对于使用像`Intl.Segmenter`等按词组分割的工具，比较容易出错，而且需要对于整个`Op`进行分词，也有很多不必要的计算。不同语言的分词规则差异巨大，例如英文空格分词以及中文无空格分词，自动识别词边界非常困难，尤其是在涉及自动换行和非罗马语言的情况下会非常困难。

- <https://github.com/facebook/lexical/blob/af687fa/packages/lexical/src/LexicalSelection.ts#L1605>

总结起来，使用`selection.modify`方法直接利用了浏览器引擎自身对选区计算的内置、高度优化的逻辑，浏览器如何分词自然是浏览器本身最熟知。此外，实际上`BeforeInput`事件还有诸多方法，词级别删除这件事本身其实也可以用`getTargetRanges`来实现。

```js
event.getTargetRanges()[0] // InputEvent
// StaticRange {startContainer: text, startOffset: 13, endContainer: text, endOffset: 14, collapsed: false}
```

## 文本拖拽

## 总结


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://mathiasbynens.be/notes/javascript-unicode>
- <http://www.ruanyifeng.com/blog/2014/12/unicode.html>
- <https://eev.ee/blog/2015/09/12/dark-corners-of-unicode>
- <https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent>
- <https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/modify>
- <https://w3c.github.io/input-events/#interface-InputEvent-Attributes>
- <https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent/getTargetRanges>
