# 编辑器文本结构变更的受控处理
先前我们主要处理了浏览器复杂`DOM`结构的默认行为，以及兼容`IME`输入法的各种输入场景，以此需要针对性地处理输入法和浏览器兼容的行为。在这里我们关注于处理文本结构性变更行为的处理，主要是针对行级别的操作、文本拖拽操作等，分别处于文本结构结构以及变更操作扩展。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

<details>
<summary><strong>从零实现富文本编辑器系列文章</strong></summary>

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)
- [从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为](./浏览器输入模式的非受控DOM行为.md)
- [从零实现富文本编辑器#9-编辑器文本结构变更的受控处理](./编辑器文本结构变更的受控处理.md)

</details>

## 概述
在当前我们主要聊的编辑器输入模式中，主要是关注于文本的半受控输入以及脏`DOM`的检测，输入状态同步是比较复杂且容易出问题的地方。而在这里我们则关注于输入同步行为扩展，例如回车、删除、拖拽文本等操作，相当于完善了编辑器整体输入模式的处理。

具体来说，执行换行和删除回车时会变更`DOM`结构，而删除文本以及拖拽文本同样是由`BeforeInput`等事件组合执行的，在编辑器中这些操作都是输入的一部分。此外，这些操作通常都是可以受控处理的，因此并不太容易出现脏`DOM`的问题，但是整体上还是有很多需要注意的点:

- 回车操作通常需要拆分当前行结构，并且还需要关注到行格式的继承问题，特别是类似于列表等结构处理起来会更复杂一些。此外由于数据结构本身的设计不同，回车的操作实现也会有很大的差异，还有诸如软回车、硬回车等不同的回车类型。
- 删除操作同样会涉及行结构的处理，即删除回车时需要合并行结构，并且也会受到数据结构本身的影响，删除可能并不会符合操作直觉，因此需要手动校正行格式。并且删除的时候还需要关注`Unicode`字符的处理，特别是类似于`Emoji`等符号的删除需要特殊处理。
- 拖拽操作同样会涉及行结构的处理，而在我们的状态管理中本就是以行为单位进行管理的，因此拖拽行级结构相对会简单，当然实现的交互上还是有些工作量。而文本节点本身同样是可以拖拽的，因此我们同样需要根据选区范围进行文本的剪切和插入。

## 回车操作
在最开始的时候，我们就聊到了`ContentEditable`的不受控行为，特别是回车操作在不同浏览器中的表现是不一致的。在之前的例子中，我们就提到了回车操作在不同浏览器中的表现差异:

- 在空`contenteditable`编辑器的情况下，直接按下回车键，在`Chrome`中的表现是会插入`<div><br></div>`，而在`FireFox(<60)`中的表现是会插入`<br>`，`IE`中的表现是会插入`<p><br></p>`。
- 在有文本的编辑器中，如果在文本中间插入回车例如`123|123`，在`Chrome`中的表现内容是`123<div>123</div>`，而在`FireFox`中的表现则是会将内容格式化为`<div>123</div><div>123</div>`。
- 同样在有文本的编辑器中，如果在文本中间插入回车后再删除回车，例如`123|123->123123`，在`Chrome`中的表现内容会恢复原本的`123123`，而在`FireFox`中的表现则是会变为`<div>123123</div>`。

其实这些示例其实也写过很多次了，每次提到浏览器的不受控行为都会提到相关的差异，这些默认行为也变成了我们处理状态同步时需要关注的点。而实际上，关于回车的行为本身我们是可以受控处理的，即阻止其默认行为，然后根据当前的选区状态进行行结构的拆分和格式继承等处理。

通常来说，我们可以通过两种方式阻止默认行为，一种是监听`BeforeInput`事件并阻止其默认行为，另一种是监听`KeyDown`事件并阻止其默认行为。前者的好处是可以直接获取到事件的输入类型，例如软硬回车等，而后者的好处则是可以更早地阻止默认行为。

那么自然的我们还是借助`BeforeInput`事件来处理回车操作，这样会比较方便一些。那么这里的实现就比较简单，理论上来说我们只需要在数据结构中插入一个`\n`的`op`即可。此外由于我们的编辑器本身不支持软回车，因此这两种类型的回车都需要统一处理为硬回车。

```js
switch (inputType) {
  case "insertLineBreak":
  case "insertParagraph": {
    this.editor.perform.insertBreak(sel);
    break;
  }
}

export class Perform {
  public insertBreak(sel: Range, attributes?: AttributeMap) {
    const raw = RawRange.fromRange(this.editor, sel);
    const start = raw.start;
    const len = raw.len;
    const delta = new Delta().retain(start);
    len && delta.delete(len);
    delta.insertEOL();
    this.editor.state.apply(delta, { range: raw });
  }
}
```

这件事看起来并没有那么复杂，因为`DOM`的结构变更处理是由我们的`LineState`以及`Mutate`模块实现的，`Mutate`模块实现了`key`值的维护以及`immutable`。接下来，在`React`适配器中，我们就可以直接以`LineState`为基准渲染行结构，渲染这件事就自然而然地交给了`React`。

```js
/**
 * 数据同步变更, 异步批量绘制变更
 */
const onContentChange = useMemoFn(() => {
    setLines(state.getLines());
});

/**
 * 监听内容变更事件, 更新当前块视图
 */
useLayoutEffect(() => {
  editor.event.on(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);
  return () => {
    editor.event.off(EDITOR_EVENT.CONTENT_CHANGE, onContentChange);
  };
}, [editor.event, onContentChange]);
```

`Mutate`模块实现的算法会比较复杂，这里就暂时先不展开了。简单来说，就是会根据当前的选区位置，找到对应的行结构，然后将其拆分为两行，并且继承当前行的格式属性。当然我们并不是`Case By Case`地处理，而是根据变更的`Delta`操作实现一个通用的变更模式。

看起来插入回车这件事就简单的结束了，然而实际上并没有，这件事复杂的点在于行格式的继承问题。那么在具体聊我们编辑器插入节点的实现之前，我们先来看一下粘贴这件事的行为，为什么突然转向聊粘贴了呢，主要是这个场景会更加的典型。

具体表现是，假如此时复制了列表的多行内容，然后将其粘贴到空行时，单论文本上是没有什么问题的。然而在多行格式上的表现是，粘贴首行的格式是列表首行格式，末尾行的内容则是普通文本格式，下面的例子中`{caret}`表示的是当前的选区光标。

```js
// 剪贴板内容
[ { insert: "123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" } ]

// 原始内容
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]

// 粘贴后内容
[ { insert: "abc123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

这个表现的根本原因是，我们的行属性是在末尾标记的，而不是在行首标记的，因此看起来表现是我们会把原始行格式挤到后边去。因此看起来非常合理的样子，而在`Quill`编辑器的表现中则是看起来是剪贴板中末尾多了个`\n`标记，即使选区复制时并未选到末尾。

```js
// 剪贴板内容
[ { insert: "123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" }, { insert: "\n", attributes: { list: "bullet" } } ]

// 原始内容
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]

// 粘贴后内容
[ { insert: "abc123" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "456" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "789" }, { insert: "\n", attributes: { list: "bullet" } },
  { insert: "def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

当然在这里的表现是由于`Quill`的实现是复制时必然序列化`HTML`内容，而且并不会像我们的编辑器一样将`ops`的`fragment`写入剪贴板中。因此看起来这个数据结构像是在末尾补充了行格式，而如果是复制的是单行内容则在剪贴板中并不会有这个表现。

同样是扁平的数据格式，在`EtherPad`中的表现其实也是类似的，剪贴板的实现也是基于`HTML`序列化反序列化的实现，但是细节上的实现是剪贴板的首尾都会是携带`\n`的换行表现。其实这个表现是因为`EtherPad`的实现是将行格式放于行首的，可以转换成类似`delta`的数据结构。

```js
[ 
  { insert: "*", attributes: { list: "bullet", lmkr: "true" } }, { insert: "123" }, { insert: "\n" },
  { insert: "*", attributes: { list: "bullet", lmkr: "true" } }, { insert: "789" }, { insert: "\n" }
]
```

这里就需要思考为什么`EtherPad`控制行格式的实现是放在行首，而不是将行格式应用到`\n`上，毕竟这种情况下还需要额外处理很多问题。其实这里很多表现是与渲染相关的，因为无论是列表、引用等行格式的`DOM`渲染都是在行首的，这样看起来行首放置额外的节点来表现是更加符合操作直觉。

实际上如果额外放置了这个节点，是需要很多额外逻辑处理的，因为行格式本质上是需要和行节点一致控制的，那么就会出现节点不匹配/不一致的问题。此外，此时的行节点文本也会因为出现额外的节点，导致需要判断是否存在该节点来处理`offset`以及文本内容的计算问题。

```js
// 正常情况
[ { insert: "*", attributes: { lmkr: "true" } }, /* ... */, { insert: "\n" } ]
// 需要在应用变更时处理的情况
[ { insert: "*", attributes: { lmkr: "true" } }, { insert: "*", attributes: { lmkr: "true" } } ]
[ { insert: "text" }, { insert: "*", attributes: { lmkr: "true" } } ]
```

那么回到插入回车这件事上，在行格式的继承上，如果接着上述的操作实现，则很容易地可以看出来行格式的继承问题。在下面的例子中，`quota`表示引用格式，如果在`Md`中引用是以`>`在行首表示的，插入回车时原始行应该保持引用格式，而下面的例子中引用格式却仅表现在了新行。

```js
[ { insert: "abc{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]
// 插入回车后 =>
[ { insert: "abc" }, { insert: "\n" }, { insert: "{caret}def" }, { insert: "\n", attributes: { quote: "true" } } ]
```

因此我们需要为格式的变成实现一些特殊的处理逻辑，如果光标在行首时，需要将这个行属性直接移动到新行上。如果光标在行尾，则将行属性保留在当前行。如果光标在行中间，则将行属性保留在当前行，并且新行合并当前行的属性，到这里我们基本就可以实现插入回车的相关逻辑了。

```js
// 当光标在行首时, 直接移动行属性
// |xx(\n {y:1}) => (\n)|xx(\n {y:1} & attributes)
if (start === startLine.start) {
  delta.insertEOL();
  const lineOffset = endLine.length - 1;
  delta.retain(lineOffset - sel.end.offset).retain(1, attributes);
  point = new Point(sel.start.line + 1, 0);
  // 当光标在行尾时, 将行属性保留在当前行
  // xx|(\n {y:1}) => xx(\n {y:1})(\n attributes)
} else if (start === startLine.start + startLine.length - 1) {
  delta.retain(1).insertEOL(attributes);
  point = new Point(sel.start.line + 1, 0);
  // 当光标在行中时, 将行属性保留在当前行, 下一行合并新属性
  // x|x(\n {y:1}) => xx(\n {y:1})(\n {y:1} & attributes)
} else {
  delta.insertEOL(startLine.attributes);
  const lineOffset = endLine.length - 1;
  const attrs = { ...startLine.attributes, ...attributes };
  delta.retain(lineOffset - sel.end.offset).retain(1, attrs);
}
```

## 删除操作


### Emoji 处理
`Unicode`可以视为`Map`，可以从数值`code point`映射到具体的字形，这样就可以直接引用符号而不需要实际使用符号本身。可能的代码点值范围是从`U+0000`到`U+10FFFF`，有超过`110`万个可能的符号，为了保持条理性，`Unicode`将此代码点范围划分为`17`个平面。

首个平面`U+0000 -> U+FFFF`称为基本多语言平面或`BMP`，包含了最常用的字符。这样`BMP`之外就剩下大约`100`万个代码点`U+010000 -> U+10FFFF`，这些代码点所属的平面称为补充平面或星面。

`JavaScript`的单个字符由无符号的`16`位整数支持，因此其无法容纳任何高于`U+FFFF`的代码点，而是需要将其拆分为代理对。这其实就是`JS`的`UCS-2`编码形式，造成了所有字符在`JS`中都是`2`个字节，而如果是`4`个字节的字符，那么就会当作两个双字节的字符处理即代理对。

其实这么说起来`UTF-8`的变长`1-4`字节的编码是无法表示的，代理对自然是可以解决这个问题。而表达`UTF-16`的编码长度要么是`2`个字节，要么是`4`个字节。在`ECMAScript 6`中引入了新的表达方式，但是为了向后兼容`ECMAScript 5`依然可以用代理对的形式表示星面。

```js
"\u{1F3A8}"
// 🎨
"\uD83C\uDFA8"
// 🎨
```

实际上在`ES6`中引入的函数也解决了字符串遍历的问题，正则表达式也提供了`u`修饰符来处理`4`字节的字符。

```js
Array.from("1🎨1")
// ["1", "🎨", "1"]
/^.$/u.test("🎨")
// true
"1🎨1".split("")
// ["1", "\uD83C", "\uDFA8", "1"]
```

另外在基本平面即低位代理对内，从`U+D800`到`U+DFFF`是一个空段，即这些码点不对应任何字符，自然可以避免原本基本平面的冲突，因此可以用来映射辅助平面的字符。高位`[\uD800-\uDBFF]`与低位`[\uDC00-\uDFFF]`恰好是`2^10 * 2^10`长度，恰好`100`多万个代码点。

```js
(0xDBFF - 0xD800 + 1) * (0xDFFF - 0xDC00 + 1) = 1024 * 1024 = 1048576
```

虽然可以已经用`Unicode`代理对的方式表达`4`字节符号，但是类似`Emoji`这些符号是可以组合的。那么这样会导致字形上看起来是单个字符，实际上是通过`\u200d`即`ZWJ`组合起来的字符，因此其长度会更长，且`ES6`的函数也是会将其拆离表现的。

```js
"🧑" + "\u200d" + "🎨"
// 🧑‍🎨
"🧑‍🎨".length
// 5
Array.from("🧑‍🎨")
// ["🧑", "‍", "🎨"]
```

### 词级文本处理
先前我们针对`Emoji`的删除做了特殊处理，因为其本身是多个字符组成的内容，所以在删除时如果直接取长度为`1`的话会导致出现遗留不可见字符的情况。那么除了`Emoji`可能存在删除多个字符的情况，使用`Alt + Del`组合键在默认情况下是删除词级别内容，同样是存在多个字符的情况。

如果仅仅是使用`ContentEditable`的情况下，浏览器会自动处理词级别的删除行为，包括`Emoji`的删除行为也是可以自动处理的。因此针对非受控输入的编辑器例如`Quill`、飞书文档的实现，是不太需要主动处理相关行为的，主要关注点在于`DOM`变更后的被动同步状态。

而在我们实现的编辑器中，因为输入的相关实现是完全基于`beforeInput`事件来处理的，是完全受控的行为，因此我们必须要主动处理删除的行为。实际上在事件中，`inputType`值是给出了`deleteWordBackward`和`deleteWordForward`的，却没有给出默认行为要删除的长度。

因此我最开始是想要么改为非受控输入，要么是通过`Intl.Segmenter`方法来主动分词实现。然而在看到`MDN`的`DEMO`之后，发现这个构造器需要传递语言参数，这样的话在编辑器中是没有办法实现的，因为编辑器中无法实际确定语言类型。

```js
const segmenterZH = new Intl.Segmenter("ZH-CN", { granularity: "word" });
const string1 = "当前所有功能都是基于插件化定义实现";
const iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();
console.log(iterator1.next().value.segment); // 当前
```

因此我去找了相关开源编辑器的实现，`slate`是完全自定义处理的行为，使用`getWordDistance`来自行计算词的距离。这样对于英文问题不大，但是对于中文词组的处理就比较差了，是以标点符号为准作为切割目标的，因此对于中文实现更像是按句删除了。

而在`Lexical`中尝试了删除词组的表现则比较符合预期，本来我以为也是非受控的输入，但是查阅源码后发现同样是基于`beforeInput`事件来处理的。那么这个表现就非常符合浏览器的行为，本来我以为也是基于`Segmenter`实现，想查看是如何处理语言问题的，发现首参数是可以不传递的。

```js
const segmenterZH = new Intl.Segmenter(undefined, { granularity: "word" });
const string1 = "当前所有功能都是基于插件化定义实现";
const iterator1 = segmenterZH.segment(string1)[Symbol.iterator]();
console.log(iterator1.next().value.segment); // 当前
```

然而，再细致地查阅源码后发现，`Lexical`并未直接使用`Segmenter`来处理分词，而是使用了`selection.modify`这个`API`来预处理选区的变更。基于这个`API`可以同步地变更选区的`DOM`引用，然后我们就可以立即得到未来的选区状态，因此就可以构造删除的范围。

```js
const root = this.editor.getContainer();
const domSelection = getRootSelection(root);
const selection = this.current;
if (!domSelection || !selection) return null;
domSelection.modify(ALERT.MOVE, direction, granularity);
const staticSel = getStaticSelection(domSelection);
if (!staticSel || this.limit()) return null;
const { startContainer } = staticSel;
if (!root.contains(startContainer)) return null;
const newRange = toModelRange(this.editor, staticSel, false);
newRange && this.set(newRange);
```

并且在`Lexical`中还解释了`beforeInput`事件以及对应的`getTargetRanges()`方法。由此先前我对于浏览器没有给出默认要删除的长度的判断是错误的，其是通过`Range`来表达的。但是注释中还提到了这个方案不可靠，其在复杂场景下可能无法正确反应操作后的选区状态。

而对于使用像`Intl.Segmenter`等按词组分割的工具，比较容易出错，而且需要对于整个`Op`进行分词，也有很多不必要的计算。不同语言的分词规则差异巨大，例如英文空格分词以及中文无空格分词，自动识别词边界非常困难，尤其是在涉及自动换行和非罗马语言的情况下会非常困难。

- <https://github.com/facebook/lexical/blob/af687fa/packages/lexical/src/LexicalSelection.ts#L1605>

总结起来，使用`selection.modify`方法直接利用了浏览器引擎自身对选区计算的内置、高度优化的逻辑，浏览器如何分词自然是浏览器本身最熟知。此外，实际上`BeforeInput`事件还有诸多方法，词级别删除这件事本身其实也可以用`getTargetRanges`来实现。

```js
event.getTargetRanges()[0] // InputEvent
// StaticRange {startContainer: text, startOffset: 13, endContainer: text, endOffset: 14, collapsed: false}
```

## 文本拖拽

## 总结


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://mathiasbynens.be/notes/javascript-unicode>
- <http://www.ruanyifeng.com/blog/2014/12/unicode.html>
- <https://eev.ee/blog/2015/09/12/dark-corners-of-unicode>
- <https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent>
- <https://w3c.github.io/input-events/#interface-InputEvent-Attributes>
- <https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent/getTargetRanges>
