# 编辑器文本结构变更的受控处理
先前我们主要处理了浏览器复杂`DOM`结构的默认行为，以及兼容`IME`输入法的各种输入场景，以此需要针对性地处理输入法和浏览器兼容的行为。在这里我们关注于处理文本结构性变更行为的处理，主要是针对行级别的操作、文本拖拽操作等，分别处于文本结构结构以及变更操作扩展。

- 开源地址: <https://github.com/WindRunnerMax/BlockKit>
- 在线编辑: <https://windrunnermax.github.io/BlockKit/>
- 项目笔记: <https://github.com/WindRunnerMax/BlockKit/blob/master/NOTE.md>

<details>
<summary><strong>从零实现富文本编辑器系列文章</strong></summary>

- [深感一无所长，准备试着从零开始写个富文本编辑器](./从零设计实现富文本编辑器.md)
- [从零实现富文本编辑器#2-基于MVC模式的编辑器架构设计](./基于MVC模式的编辑器架构设计.md)
- [从零实现富文本编辑器#3-基于Delta的线性数据结构模型](./基于Delta的线性数据结构模型.md)
- [从零实现富文本编辑器#4-浏览器选区模型的核心交互策略](./浏览器选区模型的核心交互策略.md)
- [从零实现富文本编辑器#5-编辑器选区模型的状态结构表达](./编辑器选区模型的状态结构表达.md)
- [从零实现富文本编辑器#6-浏览器选区与编辑器选区模型同步](./浏览器选区与编辑器选区模型同步.md)
- [从零实现富文本编辑器#7-基于组合事件的半受控输入模式](./基于组合事件的半受控输入模式.md)
- [从零实现富文本编辑器#8-浏览器输入模式的非受控DOM行为](./浏览器输入模式的非受控DOM行为.md)
- [从零实现富文本编辑器#9-编辑器文本结构变更的受控处理](./编辑器文本结构变更的受控处理.md)

</details>

## 概述
在当前我们主要聊的编辑器输入模式中，主要是关注于文本的半受控输入以及脏`DOM`的检测，输入状态同步是比较复杂且容易出问题的地方。而在这里我们则关注于输入同步行为扩展，例如回车、删除、拖拽文本等操作，相当于完善了编辑器整体输入模式的处理。

具体来说，执行换行和删除回车时会变更`DOM`结构，而删除文本以及拖拽文本同样是由`BeforeInput`等事件组合执行的，在编辑器中这些操作都是输入的一部分。此外，这些操作通常都是可以受控处理的，因此并不太容易出现脏`DOM`的问题，但是整体上还是有很多需要注意的点:

- 回车操作通常需要拆分当前行结构，并且还需要关注到行格式的继承问题，特别是类似于列表等结构处理起来会更复杂一些。此外由于数据结构本身的设计不同，回车的操作实现也会有很大的差异，还有诸如软回车、硬回车等不同的回车类型。
- 删除操作同样会涉及行结构的处理，即删除回车时需要合并行结构，并且也会受到数据结构本身的影响，删除可能并不会符合操作直觉，因此需要手动校正行格式。并且删除的时候还需要关注`Unicode`字符的处理，特别是类似于`Emoji`等符号的删除需要特殊处理。
- 拖拽操作同样会涉及行结构的处理，而在我们的状态管理中本就是以行为单位进行管理的，因此拖拽行级结构相对会简单，当然实现的交互上还是有些工作量。而文本节点本身同样是可以拖拽的，因此我们同样需要根据选区范围进行文本的剪切和插入。

## 回车操作
在最开始的时候，我们就聊到了`ContentEditable`的不受控行为，特别是回车操作在不同浏览器中的表现是不一致的。在之前的例子中，我们就提到了回车操作在不同浏览器中的表现差异:

- 在空`contenteditable`编辑器的情况下，直接按下回车键，在`Chrome`中的表现是会插入`<div><br></div>`，而在`FireFox(<60)`中的表现是会插入`<br>`，`IE`中的表现是会插入`<p><br></p>`。
- 在有文本的编辑器中，如果在文本中间插入回车例如`123|123`，在`Chrome`中的表现内容是`123<div>123</div>`，而在`FireFox`中的表现则是会将内容格式化为`<div>123</div><div>123</div>`。
- 同样在有文本的编辑器中，如果在文本中间插入回车后再删除回车，例如`123|123->123123`，在`Chrome`中的表现内容会恢复原本的`123123`，而在`FireFox`中的表现则是会变为`<div>123123</div>`。

其实这些示例其实也写过很多次了，每次提到浏览器的不受控行为都会提到相关的差异，这些默认行为也变成了我们处理状态同步时需要关注的点。而实际上，关于回车的行为本身我们是可以受控处理的，即阻止其默认行为，然后根据当前的选区状态进行行结构的拆分和格式继承等处理。

通常来说，我们可以通过两种方式阻止默认行为，一种是监听`BeforeInput`事件并阻止其默认行为，另一种是监听`KeyDown`事件并阻止其默认行为。前者的好处是可以直接获取到事件的输入类型，例如软硬回车等，而后者的好处则是可以更早地阻止默认行为。





## 删除操作

### Emoji 处理
`Unicode`可以视为`Map`，可以从数值`code point`映射到具体的字形，这样就可以直接引用符号而不需要实际使用符号本身。可能的代码点值范围是从`U+0000`到`U+10FFFF`，有超过`110`万个可能的符号，为了保持条理性，`Unicode`将此代码点范围划分为`17`个平面。

首个平面`U+0000 -> U+FFFF`称为基本多语言平面或`BMP`，包含了最常用的字符。这样`BMP`之外就剩下大约`100`万个代码点`U+010000 -> U+10FFFF`，这些代码点所属的平面称为补充平面或星面。

`JavaScript`的单个字符由无符号的`16`位整数支持，因此其无法容纳任何高于`U+FFFF`的代码点，而是需要将其拆分为代理对。这其实就是`JS`的`UCS-2`编码形式，造成了所有字符在`JS`中都是`2`个字节，而如果是`4`个字节的字符，那么就会当作两个双字节的字符处理即代理对。

其实这么说起来`UTF-8`的变长`1-4`字节的编码是无法表示的，代理对自然是可以解决这个问题。而表达`UTF-16`的编码长度要么是`2`个字节，要么是`4`个字节。在`ECMAScript 6`中引入了新的表达方式，但是为了向后兼容`ECMAScript 5`依然可以用代理对的形式表示星面。

```js
"\u{1F3A8}"
// 🎨
"\uD83C\uDFA8"
// 🎨
```

实际上在`ES6`中引入的函数也解决了字符串遍历的问题，正则表达式也提供了`u`修饰符来处理`4`字节的字符。

```js
Array.from("1🎨1")
// ["1", "🎨", "1"]
/^.$/u.test("🎨")
// true
"1🎨1".split("")
// ["1", "\uD83C", "\uDFA8", "1"]
```

另外在基本平面即低位代理对内，从`U+D800`到`U+DFFF`是一个空段，即这些码点不对应任何字符，自然可以避免原本基本平面的冲突，因此可以用来映射辅助平面的字符。高位`[\uD800-\uDBFF]`与低位`[\uDC00-\uDFFF]`恰好是`2^10 * 2^10`长度，恰好`100`多万个代码点。

```js
(0xDBFF - 0xD800 + 1) * (0xDFFF - 0xDC00 + 1) = 1024 * 1024 = 1048576
```

虽然可以已经用`Unicode`代理对的方式表达`4`字节符号，但是类似`Emoji`这些符号是可以组合的。那么这样会导致字形上看起来是单个字符，实际上是通过`\u200d`即`ZWJ`组合起来的字符，因此其长度会更长，且`ES6`的函数也是会将其拆离表现的。

```js
"🧑" + "\u200d" + "🎨"
// 🧑‍🎨
"🧑‍🎨".length
// 5
Array.from("🧑‍🎨")
// ["🧑", "‍", "🎨"]
```

### 词级文本处理

## 文本拖拽

## 总结


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://mathiasbynens.be/notes/javascript-unicode>
- <http://www.ruanyifeng.com/blog/2014/12/unicode.html>
- <https://eev.ee/blog/2015/09/12/dark-corners-of-unicode>
