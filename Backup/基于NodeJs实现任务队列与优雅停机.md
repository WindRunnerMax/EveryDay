
# 基于NodeJs实现任务队列与优雅停机
当在后端执行复杂的任务时，通常不能够在短时间内即时响应，例如文档导入、导出任务等。再加上当前的`LLMs`发展，我们可以实现文档的写作、质检、翻译等复杂任务，这些任务通常都比较耗时，这样就需要任务队列来管理这些异步任务的执行顺序和资源分配，而优雅停机则用以保证任务的完整处理。

<details>
<summary><strong>AI Infra 系列相关文章</strong></summary>

- [基于 fetch 的 SSE 方案](../Browser/基于fetch的SSE方案.md)
- [基于向量检索实现基础 RAG 服务](./基于向量检索实现基础RAG服务.md)
- [流式 Markdown 增量富文本解析算法](./流式Markdown增量富文本解析算法.md)
- [基于 NodeJs 实现任务队列与优雅停机](./基于NodeJs实现任务队列与优雅停机.md)

</details>

## 概述
任务队列用于管理和调度异步任务，在实现时我们可能会使用一些现成的库，例如`Bull/BullMQ`、`Agenda`等。而如果需要实现更复杂的任务/消息调度，例如不同系统、不同应用之间的可靠消息传递等服务，我们还需要使用`Kafka`、`RabbitMQ`等消息队列系统。整体来说，异步任务可以实现如下功能:

- 异步任务，将耗时的操作放到后台去处理，让主程序能够快速返回响应。
- 流量削峰，将大量请求转化为任务，平稳地存入队列，然后系统按照能承受的处理能力，从队列中取出任务进行消费。
- 错误重试，当任务执行失败时，队列可以尝试进行重试，如果重试多次后仍然失败，则可以将任务标记为失败。

优雅停机则是指在应用程序关闭时，能够正确地处理正在进行的任务，确保数据的一致性和完整性。在这里的优雅停机主要分为针对请求的处理和针对任务队列的处理，请求的部分通常会由网关加上框架本身处理，而任务队列的重置或者结束，则需要靠我们主动处理。整体来说，优雅停机通常需要做如下处理:

- 停止接收新的请求，服务需要避免新的请求进入，这部分通常需要网关等前置节点来处理。
- 处理当前请求，服务需要继续处理当前已经在处理中的请求，确保这些请求能够正常完成。
- 释放已分配资源，在请求处理完成后，需要释放所有申请的资源，例如关闭数据库连接等。
- 关闭服务，当所有请求都处理完毕且资源都已释放后，需要正常关闭服务，或者强制停机。

在本文中我们在`Nest`框架的基础上，实现简化版的分布式任务调度队列。并且基于`pm2`管理`NodeJs`进程，实现了优雅停机的能力，而且探讨了`Linux`系统下进程与信号的传递表现。文中涉及的实现都在 <https://github.com/WindRunnerMax/webpack-simple-environment> 中。

## 任务队列
多台实例以及单实例的集群模式，分布式任务队列

这些分布式任务队列库都需要接入消息队列或数据库作为后端存储

## 优雅停机

## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考
- <https://docs.nestjs.com/modules>
- <https://pm2.keymetrics.io/docs/usage/signals-clean-restart/>
- <https://github.com/WindRunnerMax/webpack-simple-environment>

