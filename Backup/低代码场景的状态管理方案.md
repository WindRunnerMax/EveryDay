# 低代码场景的状态管理方案
在复杂应用中，例如低代码、富文本编辑器的场景下，数据结构的设计就显得非常重要，这种情况下的状态管理并非是`redux`、`mobx`等通用解决方案，而是需要针对具体场景进行定制化设计，那么在这里我们来尝试基于`Immer`以及`OT-JSON`实现原子化、可协同、高扩展的应用级状态管理方案。

## 描述
将`Immer`与`OT-JSON`结合的想法来自于`slate`，我们首先来看一下`slate`的基本数据结构，下面的例子是高亮块的描述。这个数据结构看起来非常像零代码/低代码的结构，因为其含有很多`children`，而且存在对节点的装饰描述，即`bold`、`border`、`background`等属性值。

```js
[
  {
    "highlight-block": {
      border: "var(--arcoblue-6)",
      background: "var(--arcoblue-3)",
    },
    children: [
      { children: [{ text: "🌰 " }, { text: "举个栗子", bold: true }] },
      { children: [{ text: "支持高亮块 可以用于提示文档中的重要内容。" }] },
    ],
  },
];
```

那么这里的设计就很有趣，之前的文章中我们就聊过，本质上低代码和富文本都是基于`DSL`的描述来操作`DOM`结构，只不过富文本主要是通过键盘输入来操作`DOM`，而无代码则是通过拖拽等方式来操作`DOM`，这里当然是有些共通的设计思路，这个结论其实就是来自于`slate`的状态管理。

### 基本原则
前边我们也提到了数据结构的具体场景进行定制化设计，这部分主要指的是`JSON`的结构非常灵活，像是高亮块的描述，我们可以将其设计为单独的对象，也可以将其拍平，以`Map`的形式来描述节点的装饰，再例如上述文本内容则规定了需要用`text`属性描述。

原子化的设计非常重要，在这里我们将原子化分为两部分，结构的原子化与操作的原子化。结构的原子化意味着我们可以将节点自由组合，而操作的原子化则意味着我们可以通过描述来操作节点状态，这两者的组合可以方便地实现组件渲染、状态变更、历史操作等等。

节点的自由组合可以应用在很多场景中，例如表单结构中，任何一个表单项都可以都可以变为其他表单项的嵌套结构，组合模式可以设定部分规则来限制。操作的原子化可以更方便地处理状态变更，同样是在表单中，嵌套的表单项展开/折叠状态就需要通过状态变更实现。

协同算法的基础同样是原子化的操作，类似于`redux`的范式`action`操作非常方便，但是却无法处理协同冲突，同样也不容易处理历史操作等。这一局限性源于其单向、离散的操作模型，每个`action`仅表达独立意图，而缺乏对全局状态因果关系(操作`A`影响操作`B`状态)的显式维护。

`OT-JSON`则可以帮助我们将原子化的操作，扩展到协同编辑的复杂场景中，通过引入操作变换`OT`，以此来解决冲突。当然仅仅是前端引入操作变换是不够的，还需要引入后端的协同框架，例如`ShareDB`等。当然，`CRDT`的协同算法也是可行的选择，这属于应用的选型问题了。

此外，`OT-JSON`天然可以支持操作历史的维护，每个操作都携带了足够的上下文信息，使得系统能够追溯状态变化的完整链条，为撤销/重做、版本回溯等高级功能提供了基础。操作之间的因果关系也被显式地记录下来，使得系统能够做到操作`A`必须在操作`B`之前应用这样的约束条件。

扩展性这部分的设计可以是比较丰富的，，树形结构天然适合承载嵌套式数据交互。例如飞书文档的各种模块，都是以`Blocks`的形式扩展出来的。恰好飞书的数据结构协同也是使用`OT-JSON`来实现的，文本的协同则是借助了`EasySync`作为`OT-JSON`的子类型来实现的，以此来提供更高的扩展性。

当然，扩展性并不是说可以完全自由地接入插件，插件内的数据结构还是需要整体接受`OT-JSON`的调度，并且文本这种特殊的子类型也要单独调度。以此系统框架能够将各种异构内容模块统一纳入协同体系，并且可以实现统一的状态管理、协同编辑、历史记录等功能。

### Immer
`Immer`简化了不可变数据的操作，引入一种称为草稿状态的概念，以此允许开发者以直观的可变方式编写代码，同时底层自动生成全新的不可变对象。传统方式中，修改深层嵌套的数据需要小心翼翼地展开每一层结构，既容易出错又让代码显得复杂。

```js
const reducer = (state, action) => {
  return {
    ...state,
    first: {
      ...state.first,
      second: {
        ...state.first.second,
        value: action,
      },
    },
  };
};
```

而`Immer`通过创建一个临时的草稿对象，让开发者像操作普通对象一样直接赋值、增删属性，甚至使用数组的`push`、`pop`等方法。完成所有修改后，便基于草稿状态的变更记录，生成变更后与原始数据结构共享未修改部分的新对象。这种机制既避免了深拷贝的性能损耗，又保证了数据的不可变性。

```js
const reducer = (state, action) => {
  state.first.second.value = action;
};
```

在`Immer`中非常重要的一点是，在使用`Proxy`代理修改这个过程中，仅在访问到数据的时候才会创建`Proxy`对象，也就是说这是一种按需代理的懒代理机制，这样就不需要创建草稿时遍历创建所有代理。这种机制极大地减少了不必要的性能开销，尤其当处理大型复杂对象时。

例如修改了一个深层嵌套属性`draft.a.b.c = 1`，`Immer`会沿着访问路径逐层生成代理，`Proxy(a)`、`Proxy(a.b)`、`Proxy(a.b.c)`。因此使用`Immer`的时候还需要注意，在修改对象的时候尽可能保持仅读取需要修改的部分，其他的代理操作要在草稿，避免不必要的代理生成。

### OT-JSON
在`slate`中实现了`9`种原子操作来描述变更，这其中包含了文本处理`insert_text`、节点处理`insert_node`、选区变换`set_selection`的操作等。但是在`slate`中虽然实现了操作变换与操作反转等，但是并未单独抽离独立的包，因此很多设计都是内部实现的，不具有通用性。

- `insert_node`: 插入节点。
- `insert_text`: 插入文本。
- `merge_node`: 合并节点。
- `move_node`: 移动节点。
- `remove_node`: 移除节点。
- `remove_text`: 移除文本。
- `set_node`: 设置节点。
- `set_selection`: 设置选区。
- `split_node`: 分割节点。

类似的，在`OT-JSON`中实现了`11`种操作，且`json0`的结构设计已经过了广泛的生产环境验证，核心目标是通过结构化的数据表达，确保不同客户端之间的数据一致性。此外，富文本场景中`SubType`仍然需要扩展，例如飞书的`EasySync`类型扩展，那自然就需要更多的操作来描述变更。

- `{p:[path], na:x}`: 在指定的路径`[path]`值上加`x`数值。
- `{p:[path,idx], li:obj}`: 在列表`[path]`的索引`idx`前插入对象`obj`。
- `{p:[path,idx], ld:obj}`: 从列表`[path]`的索引`idx`中删除对象`obj`。
- `{p:[path,idx], ld:before, li:after}`: 用对象`after`替换列表`[path]`中索引`idx`的对象`before`。
- `{p:[path,idx1], lm:idx2}`: 将列表`[path]`中索引`idx1`的对象移动到索引`idx2`处。
- `{p:[path,key], oi:obj}`: 向路径`[path]`中的对象添加键`key`和对象`obj`。
- `{p:[path,key], od:obj}`: 从路径`[path]`中的对象中删除键`key`和值`obj`。
- `{p:[path,key], od:before, oi:after}`: 用对象`after`替换路径`[path]`中键`key`的对象`before`。
- `{p:[path], t:subtype, o:subtypeOp}`: 对路径`[path]`中的对象应用类型为`t`的子操作`o`，子类型操作。
- `{p:[path,offset], si:s}`: 在路径`[path]`的字符串的偏移量`offset`处插入字符串`s`，内部使用子类型。
- `{p:[path,offset], sd:s}`: 从路径`[path]`的字符串的偏移量`offset`处删除字符串`s`，内部使用子类型。

除了原子化的操作之外，最核心的就是操作变换的算法实现，这部分是协同的基础。`JSON`的原子操作并非完全独立的，必须要通过操作变换来保证操作的执行顺序可以遵循其因果依赖。同时，对于操作反转的实现也是非常重要的，这部分意味着我们可以实现撤销、重做等功能。

## 数据结构
在低代码、富文本、画板/白板、表单引擎等等编辑器应用场景中，仅仅是使用`JSON`数据结构来描述内容是不够的。类比在组件中，`div`是描述视图的，状态是需要额外定义的，并且通过事件驱动来改变状态。而在编辑器场景中，`JSON`既是视图描述也是要操作的状态。

那么基于`JSON`来渲染视图这件事并不复杂，特别是在表格渲染中的场景会很常见。而通过操作来变更数据结构则并没有那么简单，那么基于`OT-JSON`我们可以实现原子化的数据变更，与`Immer`结合则可以配合视图的渲染刷新，在这里我们先以单元测试的方式测试数据结构的操作变换。

### 基本操作

### 操作变换

### 批量应用

## 低代码场景
抽象出列表

### 数据操作
使用 ot-json 而没有 immer 会导致添加节点并未刷新视图 

### 路径查找
findPath effect/for-end

### 选区状态
selection hooks provider 按需render 

### History
history 变换

## 总结


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://github.com/immerjs/immer>
- <https://github.com/ottypes/json0>
- <https://zhuanlan.zhihu.com/p/602961293>
- <https://github.com/ianstormtaylor/slate/>
- <https://stackoverflow.com/questions/34385243/why-is-immutability-so-important-or-needed-in-javascript>

