# 低代码场景的状态管理方案
在复杂应用中，例如低代码、富文本编辑器的场景下，数据结构的设计就显得非常重要，这种情况下的状态管理并非是`redux`、`mobx`等通用解决方案，而是需要针对具体场景进行定制化设计，那么在这里我们来尝试基于`Immer`以及`OT-JSON`实现原子化、可协同、高扩展的应用级状态管理方案。

## 描述
将`Immer`与`OT-JSON`结合的想法来自于`slate`，我们首先来看一下`slate`的基本数据结构，下面的例子是高亮块的描述。这个数据结构看起来非常像零代码/低代码的结构，因为其含有很多`children`，而且存在对节点的装饰描述，即`bold`、`border`、`background`等属性值。

```js
[
  {
    "highlight-block": {
      border: "var(--arcoblue-6)",
      background: "var(--arcoblue-3)",
    },
    children: [
      { children: [{ text: "🌰 " }, { text: "举个栗子", bold: true }] },
      { children: [{ text: "支持高亮块 可以用于提示文档中的重要内容。" }] },
    ],
  },
];
```

那么这里的设计就很有趣，之前的文章中我们就聊过，本质上低代码和富文本都是基于`DSL`的描述来操作`DOM`结构，只不过富文本主要是通过键盘输入来操作`DOM`，而无代码则是通过拖拽等方式来操作`DOM`，这里当然是有些共通的设计思路，这个结论其实就是来自于`slate`的状态管理。

### 基本原则
前边我们也提到了数据结构的具体场景进行定制化设计，这部分主要指的是`JSON`的结构非常灵活，像是高亮块的描述，我们可以将其设计为单独的对象，也可以将其拍平，以`Map`的形式来描述节点的装饰，再例如上述文本内容则规定了需要用`text`属性描述。

原子化的设计非常重要，在这里我们将原子化分为两部分，结构的原子化与操作的原子化。结构的原子化意味着我们可以将节点自由组合，而操作的原子化则意味着我们可以通过描述来操作节点状态。这两者的组合可以方便地实现组件渲染、状态变更、历史操作等等。

节点的自由组合可以应用在很多场景中，例如表单结构中，任何一个表单项都可以都可以变为其他表单项的嵌套结构，组合模式可以设定部分规则来限制。操作的原子化可以更方便地处理状态变更，同样是在表单中，嵌套的表单项展开/折叠状态就需要通过状态变更实现。

飞书 Blocks


### Immer

### OT-JSON 
json0
slate 低代码 数据结构很像 但是没有单独抽离包


## 数据结构
在低代码、富文本、画板/白板、表单引擎等等编辑器应用场景中，仅仅是使用`JSON`数据结构来描述内容是不够的。类比在组件中，`div`是描述视图的，状态是需要额外定义的，并且通过事件驱动来改变状态。而在编辑器场景中，`JSON`既是视图描述也是要操作的状态。

那么基于`JSON`来渲染视图这件事并不复杂，特别是在表格渲染中的场景会很常见。而通过操作来变更数据结构则并没有那么简单，那么基于`OT-JSON`我们可以实现原子化的数据变更，与`Immer`结合则可以配合视图的渲染刷新，在这里我们先以单元测试的方式测试数据结构的操作变换。

### 基本操作

### 操作变换

### 批量应用

## 低代码场景
抽象出列表

### 数据操作
使用 ot-json 而没有 immer 会导致添加节点并未刷新视图 

### 路径查找
findPath effect/for-end

### 选区状态
selection hooks provider 按需render 

### History
history 变换

## 总结


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>

## 参考

- <https://github.com/immerjs/immer>
- <https://github.com/ottypes/json0>
- <https://github.com/ianstormtaylor/slate/>

