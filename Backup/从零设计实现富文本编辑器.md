# 从零设计实现富文本编辑器
富文本编辑器是允许用户在输入和编辑文本内容时，可以应用不同的格式、样式等功能，例如图文混排等，具有所见即所得的能力。与简单的纯文本编辑组件`<input>`等不同，富文本编辑器提供了更多的功能和灵活性，让用户可以创建更丰富和结构化的内容。现代的富文本编辑器也已经不仅限于文字和图片，还包括视频、表格、代码块、附件、公式等等比较复杂的模块。

- 开源地址: <https://github.com/WindRunnerMax/QuillBlocks>
- 项目笔记: <https://github.com/WindRunnerMax/QuillBlocks/blob/master/NOTE.md>

## Why?
那么为什么要从零设计实现新的富文本编辑器，编辑器是公认的天坑，且当前已经有很多优秀的编辑器实现。例如极具表现力的数据结构设计`Quill`、结合`React`视图层的`Draft`、纯粹的编辑器引擎`Slate`、高度模块化的`ProseMirror`、开箱即用的`TinyMCE/TipTap`、集成协同解决方案的`EtherPad`等等。

我也算是比较关注于各类富文本编辑器的实现，包括在各个站点上的编辑器实现文章我也会看。但是我发现这其中极少有讲富文本编辑器的底层设计，绝大多数都是将的应用层，例如如何使用编辑器引擎实现某某功能等。这些应用层的实现本身也会有一定复杂性，但是底层的设计却是更值得探讨的问题。

此外，我觉得富文本编辑器很类似于低代码的设计，准确来说是`No Code`的一种实现。本质上低代码和富文本都是基于`DSL`的描述来操作`DOM`结构，只不过富文本主要是通过键盘输入来操作`DOM`，而无代码则是通过拖拽等方式来操作`DOM`，我想这里应该是有些共通的设计思路。

而我恰好前段时间都在专注于编辑器的应用层实现，在具体实现的过程中也遇到了很多问题，并且记录了相关文章。然而在应用层实现的过程中，遇到了很多我个人觉得可以优化的地方，特别是在数据结构层面上，希望能够将我的一些想法应用出来。而具体来说，主要有下面的几个原因:

## 编辑器专栏
纸上得来终觉浅，绝知此事要躬行。

我的博客是从`20`年开始写的，记录的内容很多，基本上是想到什么就写什么，毕竟是作为平时学习的记录。然后在`24`年写了比较多的富文本编辑器的文章，主要是整理了平时遇到的问题以及解决方案，集中在应用层的设计上，例如:

- [初探富文本之文档虚拟滚动](https://github.com/WindRunnerMax/EveryDay/blob/master/RichText/初探富文本之文档虚拟滚动.md)
- [初探富文本之OT协同算法](https://github.com/WindRunnerMax/EveryDay/blob/master/RichText/初探富文本之OT协同算法.md)
- [...](https://github.com/WindRunnerMax/EveryDay#richtext)

此外，前段时间还研究了`slate`富文本编辑器相关的实现，并且也给`slate`的仓库提过一些`PR`。还写了一些`slate`相关的文章，并且还基于`slate`实现了一个文档编辑器，同样也是比较关注于应用层的实现，例如:

- [WrapNode数据结构与操作变换](https://github.com/WindRunnerMax/EveryDay/blob/master/RichText/WrapNode数据结构与操作变换.md)
- [Node节点与Path路径映射](https://github.com/WindRunnerMax/EveryDay/blob/master/RichText/Node节点与Path路径映射.md)
- [...](https://github.com/WindRunnerMax/EveryDay#richtext)


在实现了诸多的应用层的功能之后，发现整个编辑器有很多可以深入研究的地方。特别是有些实现看似很理所当然，但是仔细研究起来会发现这其中有很多细节可以探究，例如在`DOM`结构后常见的零宽字符、`Mention`节点的渲染等等，这些内容都可以单独拿出来记录文章，这其实就是我想从零实现编辑器的最重要原因。

`24`年开始写了很多业务上的东西，到了`25`年就略感题穷，而目前我也没有别的擅长的方面，由此写编辑器相关的内容是比较好的选择，这样对于文章的选题也会简单些。不过，虽然想的是深入写编辑器相关的内容，但是在平时遇到问题的时候，还是会记录下来，例如最近有个基于`immer`配合`OT-JSON`实现的状态管理的想法可以实现。

而对于编辑器的具体实现，我目前的目标是实现可用的编辑器，而不是兼容性非常好且功能完备的编辑器。主要是现在已经有非常多优秀的编辑器实现，且有很多生态插件可以支持，能够满足大部分的需求。目前我想实现的编辑器主要是兼容`Chrome`浏览器即可，移动端的问题暂时不会考虑。不过，如果能够将编辑器做得比较好的话，自然可以去做兼容性适配。

不过目前还是试探性地来设计并实现编辑器，期间必然会遇到很多问题，这些问题也将会成为专栏的主体内容。如果将来真的能够将编辑器适用于生产环境，那么这些文章就能够溯源到模块为什么这么设计，想必也是极好的。整体来说，我们不能一口吃成胖子，但是一口一口吃却是可以的。

### 深入编辑器
这部分是让我想起来一句话：我们富文本编辑器是这样的，你不写你不懂。

编辑器是个非常注重细节的工程，很多时候都需要深入研究浏览器的`API`，例如`document`上的`caretPositionFromPoint`方法，用以获取当前某个点所在的选区位置，通常用于拖拽文本后的落点定位。除此之外，还有很多选区相关的`API`，例如`Selection`、`Range`等等，这些都是编辑器实现的基础。

那么深入编辑器底层就是很有意义的事情，很多时候我们都需要跟浏览器打交道，即使是对我们平时的业务开发也会有价值。在这里我想聊一下编辑器中的零宽字符，以此例学习编辑器的细节设计，这是一个非常有意思的话题，类似这种内容就是不研究则不会关注到的有趣事情。

零宽字符顾名思义是没有宽度的字符，因此就很容易推断出这些字符在视觉上是不显示的。因此这些字符就可以作为不可见的占位内容，实现特殊的效果。例如可以实现信息隐藏，以此来实现水印的功能，以及加密的信息分享等等，某些小说站点会通过这种方式以及字形替换来追溯盗版。

而在富文本编辑器中，如果我们在开发者工具检查元素时，可能会发现一些类似于`&ZeroWidthSpace;`即`U+200B`类似的字符，这就是常见的零宽字符。例如在飞书文档的编辑器中，我们通过`$("[data-enter]")`就可以检查到其中存在的零宽字符。

```html
<!-- document.querySelectorAll("[data-enter]") -->
<span data-string="true" data-enter="true" data-leaf="true">\u200B</span>
<span data-string="true" data-enter="true" data-leaf="true">&ZeroWidthSpace;</span>
```

那么从名字上来看，这个零宽字符在视觉上是不显示的，因为其是零宽度。但是在编辑器中，这个字符却是很重要的。简单来说，我们需要这个字符来放置光标，以及做额外的显示效果。需要注意的是我们在这里指的是`ContentEditable`实现的编辑器，如果是自绘选区的编辑器则不一定需要这部分设计。

我们先来聊一下额外的显示效果，举个例子，我们在选择飞书文档文本内容，如果选中到文本末尾时，会发现末尾会额外多出形似`xxx|`的效果。在平时不关注的话可能会觉得这是编辑器默认行为，但是实际上这个效果无论是`slate`还是`quill`中都是不存在的。

实际上这个效果就是使用零宽字符来实现的，在行内容的末尾后面插入零宽字符，就可以做到末尾的文本选中效果。实际上这个效果在`word`中更常见，也就是额外渲染的回车符号。

```html
<div contenteditable="true">
  <div><span>末尾零宽字符 Line 1</span><span>&#8203;</span></div>
  <div><span>末尾零宽字符 Line 2</span><span>&#8203;</span></div>
  <div><span>末尾纯文本 Line 1</span></div>
  <div><span>末尾纯文本 Line 2</span></div>
</div>
```

那么在这个零宽字符如果只是渲染效果的话，那么可能实际上起的作用并不很必要。但是在交互上这个效果却很有用，例如此时我们有`3`行文本，如果此时从第`1`行末尾选到第`2`行时，并且按下`Tab`键，那么此时这两行的内容就会缩进。

那么如果没有这个显示效果，此时进行缩进操作，用户可能认为仅仅是选中了第`2`行，但是实际上是选中了`1/2`两行文本。这样的话用户可能会以为是`BUG`，而我们也实际接受过这个交互效果的反馈。

```plain
123|
4|x56
```

也对各个在线文档实现进行了简单调研: 基于`contenteditable`实现的编辑器中，飞书文档、早期`EtherPad`存在这个交互实现；自绘选区的编辑器中，钉钉文档存在这个实现；`Canvas`引擎实现的编辑器中，腾讯文档、`Google Doc`存在这个实现。

在渲染效果部分，零宽字符还有一个重要的作用是撑起行内容。当我们的行内容为空时，此时这个行`DOM`结构的内容就是空，这就导致此行的高度塌陷为`0`，且无法放置光标。为了解决这个问题，我们可以选择在行内容中插入零宽字符，这样就可以撑起行内容且可以放置光标。当然使用`<br>`来撑起行高也是可以的，使用这两种方案会各有优劣，且兼容性方面也有所不同。

```html
<div data-line-node></div>
<div data-line-node><br></div>
<div data-line-node><span>&#8203;</span></div>
```

在类似于`Notion`这种块结构的编辑器中，还有个比较重要的交互效果。即块级结构独立选择，例如我们可以直接将整个代码块独立选出来，而不是仅仅能选择其中的文本。这种效果在目前的开源编辑器很少有实现，都是需要自行以块结构重新组织设计选区。

通常来说，这个交互同样可以使用零宽字符来实现。因为我们的选区通常是需要放置在文本节点上的，因此我们很容易可以想到，可以在块结构所在行的末尾放置零宽字符，当选区在零宽字符上时就将整个块选中。这里用零宽字符而不是`<br>的好处是，零宽字符本身就是零宽，不会引起额外的换行。

```html
<div>
  <pre><code>
    xxx
  </code></pre>
  <span data-zero-block>&#8203;</span>
</div>
```

在结构上，零宽字符还有个非常重要的实现。在编辑器内的`contenteditable=false`节点会存在特殊的表现，在类似于`inline-block`节点中，例如`Mention`节点中，当节点前后没有任何内容时，我们就需要在其前后增加零宽字符，用以放置光标。

在下面的例子中，`line-1`是无法将光标放置在`@xxx`内容后的，虽然我们能够将光标放置之前，但此时光标位置是在`line node`上，是不符合我们预期的文本节点的。那么我们就必须要在其后加入零宽字符，在`line-2/3`中我们就可以看到正确的光标放置效果。这里的`0.1px`也是个为了兼容光标的放置的`magic`，没有这个`hack`的话，非同级节点光标同样无法放置在`inline-block`节点后。

```html
<div contenteditable style="outline: none">
  <div data-line-node="1">
    <span data-leaf><span contenteditable="false" style="margin: 0 0.1px;">@xxx</span></span>
  </div>
  <div data-line-node="2">
    <span data-leaf>&#8203;</span>
    <span data-leaf><span contenteditable="false" style="margin: 0 0.1px;">@xxx</span></span>
    <span data-leaf>&#8203;</span>
  </div>
  <div data-line-node="3">
    <span data-leaf>&#8203;<span contenteditable="false">@xxx</span>&#8203;</span>
  </div>
</div>
```

### 数据结构设计
编辑器数据结构的设计是影响面非常广的事情，无论是在维护编辑器的文本内容、块结构嵌套、序列化反序列化等，还是平台应用层面上的`diff`算法、查找替换、协同算法等，以及后端服务的数据转换、导出`md/word/pdf`、数据存储等，都会涉及到编辑器的数据结构设计。

通常来说，基于`JSON`嵌套的数据结构来表达编辑器`Model`是很常见的，例如`Slate`、`ProseMirror`、`Lexical`等等。以`slate`编辑器为例，无论是数据结构还是选区的设计，都尽可能倾向于`HTML`的设计，因此可以存在诸多层级节点的嵌套。

```js
[
  {
    type: "paragraph",
    children: [{ text: "editable" }],
  },
  {
    type: "ul",
    children: [
      {
        type: "li",
        children: [{ text: "list" }],
      },
    ],
  },
];
```

通过线性的扁平结构来表达文档内容也是常见的实现方案，例如`Quill`、`EtherPad`、`Google Doc`等等。以`quill`编辑器为例，其内容上的数据结构表达不会存在嵌套，当然本质上还是`JSON`结构，而选区则采用了更精简的表达。

```js
[
  { insert: "editable\n" },
  { insert: "list\n", attributes: { list: "bullet" } },
];
```

当然还有很多特别的数据结构设计，例如`vscode/monaco`的`piece table`数据结构。代码编辑器又何尝不是一种富文本编辑器，毕竟其是可以支持代码高亮的功能的，只不过类似`piece table`的结构我还没有太深入研究。

在这里我希望能够以线性的数据结构来表达整个富文本结构，虽然嵌套的结构能够更加直观地表达文档内容，但是对于内容的操作起来会更加复杂，特别是存在嵌套的内容时。以`slate`为例，在`0.50`之前的版本`API`设计非常复杂，需要比较大的理解成本，虽然之后将其简化了不少:

```js
// https://github.com/ianstormtaylor/slate/blob/6aace0/packages/slate/src/interfaces/operation.ts
export type NodeOperation =
  | InsertNodeOperation
  | MergeNodeOperation
  | MoveNodeOperation
  | RemoveNodeOperation
  | SetNodeOperation
  | SplitNodeOperation;
export type TextOperation = InsertTextOperation | RemoveTextOperation;
```

从这里可以看出来，`slate`对于文档内容的完整操作是需要`9`种类型的`Op`。而如果是基于线性结构的话，我们就只需要三种类型的操作，即可表达整个文档的操作。当然对于一些类似`Move`的操作，则需要额外的选区`Range`计算处理，相当于将计算成本移交到了应用层。

```js
// https://github.com/WindRunnerMax/QuillBlocks/blob/c24b9e/packages/delta/src/delta/interface.ts
export interface Op {
  // Only one property out of {insert, delete, retain} will be present
  insert?: string;
  delete?: number;
  retain?: number;

  attributes?: AttributeMap;
}
```

此外，嵌套结构的`normalize`会变得很复杂，且变更造成的时间复杂度也会变高，特别是脏路径标记算法，以及标记后的数据处理也需要由上述`Op`处理。还有用户操作导致的嵌套层级无法非常好地控制，就要`normalize`过程时规范数据，否则例如粘贴`HTML`时就可能会出现大量的数据嵌套。

```js
[{
  children: [{
    children: [{
      children: [{
        children: [{
          // ...
          text: "content"
        }]
      }]
    }]
  }]
}]
```

扁平的数据结构在数据处理方面会存在优势，而在视图层面上，扁平的数据结构表达结构化的数据会是比较困难的，例如表达代码块、表格等嵌套结构。但是这件事并非是不可行的，例如`Google Doc`的复杂表格嵌套就是完全的线性结构，这其中是存在很巧妙的设计在里边的。

最后还是有协同相关的实现，协同算法是富文本编辑器的可选模块。无论是基于`OT`的协同算法，还是`Op-Based CRDT`的协同算法，都是需要传输上述的`op`类型与数据的，那么很显然`9`种操作的`op`类型会比`3`种操作的`op`类型更加复杂。

因此，我希望能够以线性的数据结构来实现整个编辑器结构，这样`quill`的`delta`就是非常好的选择。但是`quill`是自行实现的视图层结构，并非是可以组合`react`等视图层的形式，组合这些视图层的优势就是可以直接使用组件库样式来实现编辑器，而避免了每个组件都需要自行实现。那么这里我准备基于`quill`的数据结构，来从零实现富文本编辑器核心层，并且像`slate`一样以此组合基本的视图层。

## 方案选型
实现`ContentEditable`的编辑器

### execCommand
<div contenteditable></div>

```plain
data:text/html,<div contenteditable style="border: 1px solid black"></div>
```
https://github.com/jaredreich/pell

### ContentEditable

### Canvas


## 每日一题

- <https://github.com/WindRunnerMax/EveryDay>


## 参考
- <https://github.com/w3c/editing>
- <https://zhuanlan.zhihu.com/p/407713779>
- <https://zhuanlan.zhihu.com/p/425265438>
- <https://zhuanlan.zhihu.com/p/259387658>
- <https://www.zhihu.com/question/38699645>
- <https://www.zhihu.com/question/404836496>
- <https://juejin.cn/post/6974609015602937870>
- <https://github.com/yoyoyohamapi/book-slate-editor-design>
- <https://github.com/grassator/canvas-text-editor-tutorial>
- <https://cdacamar.github.io/data%20structures/algorithms/benchmarking/text%20editors/c++/editor-data-structures/>
