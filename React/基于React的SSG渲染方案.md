# 基于React的SSG渲染方案
静态站点生成`SSG - Static Site Generation`是一种在构建时生成静态`HTML`文件资源的方法，其可以完全不需要服务端的运行，通过预先生成静态文件，实现快速的内容加载和高度的安全性。由于其生成的是纯静态资源，便可以利用`CDN`等方案以更低的成本和更高的效率来构建和发布网站，在博客、知识库、`API`文档等场景有着广泛应用。


## 描述
在前段时间遇到了一个比较麻烦的问题，我们是主要做文档业务的团队，而由于对外的产品文档涉及到全球很多地域的用户，因此在`CN`以外地域的网站访问速度就成了比较大的问题。虽然我们有多区域部署的机房，但是每个地域机房的数据都是相互隔离的，而实际上很多产品并不会做很多特异化的定制，因此文档实际上是可以通用的，特别是提供了多语言文档支持的情况下，各地域共用一份文档也变得合理了起来。而即使对于`CN`和海外地区有着特异化的定制，但在海外本身的访问也会有比较大的局限，例如假设机房部署在`US`，那么在`SG`的访问速度同样也会成为一件棘手的事情。

那么问题来了，如果我们需要做到各地域访问的高效性，那么就必须要在各个地域的主要机房部署服务，而各个地域又存在数据隔离的要求，那么在这种情况下我们可能需要手动将文档复制到各个机房部署的服务上去，这必然就是一件很低效的事情，即使某个产品的文档不会经常更新，但是这种人工处理的方式依然是会耗费大量精力的，显然是不可取的。而且由于我们的业务是管理各个产品的文档，在加上在海外业务不断扩展的情况下，这类的反馈需求必然也会越来越多，那么解决这个问题就变成了比较重要的事情。

那么在这种情况下，我就忽然想到了我的博客站点的构建方式，为了方便我会将博客直接通过`gh-pages`分支部署在`GitHub Pages`上，而`GitHub Pages`本身是不支持服务端部署的，也就是说我的博客站全部都是静态资源。由此可以想到在业务中我们的文档站也可以用类似的方式来实现，也就是在发布文档的时候通过`SSG`编译的方式来生成静态资源，那么在全部的内容都是静态资源的情况下，我们就可以很轻松地基于`CDN`来实现跨地域访问的高效性。此外除了调度`CDN`的分发方式，我们还可以通过将静态资源发布到业务方申请的代码仓库中，然后业务方就可以自行部署服务与资源了，通过多机房部署同样可以解决跨地域访问的问题。

当然，因为要考虑到各种问题以及现有部署方式的兼容，在我们的业务中通过`SSG`来单独部署实现跨地域的高效访问并不太现实，最终大概率还是要走合规的各地域数据同步方案来保证数据的一致性与高效访问。但是在思考通过`SSG`来作为这个问题的解决方案时，我还是很好奇如何在`React`的基础上来实现`SSG`渲染的，毕竟我的博客就可以算是基于`Mdx`的`SSG`渲染。最开始我把这个问题想的特别复杂，但是在实现的时候发现只是实现基本原理的话还是很粗暴的解决方案，在渲染的时候并没有想象中要处理得那么精细，当然实际上要做完整的方案特别是要实现一个框架也不是那么容易的事情，对于数据的处理与渲染要做很多方面的考量。

在我们正式开始聊`SSG`的基本原理前，我们可以先来看一下通过`SSG`实现静态站点的特点: 

* 访问速度快: 静态网站只是一组预先生成的`HTML`、`CSS`、`JavaScript`、`Image`等静态文件，没有运行在服务器上的动态语言程序，在部署于`CDN`的情况下，用户可以直接通过边缘节点高效获取资源，可以减少加载时间并增强用户体验。
* 部署简单: 静态网站可以在任何托管服务上运行，例如`GitHub Pages`、`Vercel`等，我们只需要传输文件即可，无需处理服务器配置和数据库管理等，如果借助`Git`版本控制和`CI/CD`工具等，还可以比较轻松地实现自动化部署。
* 资源占用低: 静态网站只需要非常少的服务器资源，这使得其可以在低配置的环境中运行，我们可以在较低配置的服务器上借助`Nginx`轻松支撑`10k+`的`QPS`网站访问。
* `SEO`优势: 静态网站通常对搜索引擎优化`SEO`更加友好，预渲染的页面可以拥有完整的`HTML`标签结构，并且通过编译可以使其尽可能符合语义化结构，这样使得搜索引擎的机器人更容易抓取和索引。

那么同样的，通过`SSG`生成的静态资源站点也有一些局限性:

* 实时性不强: 由于静态站点需要提前生成，因此就无法像动态网站一样根据实时的请求生成对应的内容，例如当我们发布了新文档之后，就必须要重新进行增量编译甚至是全站全量编译，那么在编译期间就无法访问到最新的内容。
* 不支持动态交互: 静态站点通常只是静态资源的集合，因此在一些动态交互的场景下就无法实现，例如用户登录、评论等功能，当然这些功能可以通过客户端渲染时动态支持，那么这种情况就不再是纯粹的静态站点，通常是借助`SSG`来实现更好的首屏和`SEO`效果。

综上所述，`SSG`更适用于生成内容较为固定、不需要频繁更新、且对于数据延迟敏感较低的的项目，并且实际上我们可能也只是选取部分能力来优化首屏等场景，最终还是会落到`CSR`来实现服务能力。当我们要选择渲染方式的时候，还是要充分考虑到业务场景，由此来确定究竟是`CSR - Client Side Render`、`SSR - Server Side Render`、`SSG - Static Site Generation`更适合我们的业务场景，甚至在一些需要额外优化的场景下，`ISR - Incremental Static Regeneration`、`DPR - Distributed Persistent Rendering`、`ESR - Edge Side Rendering`等也可以考虑作为业务上的选择。 

当然，回到最初我们提到的问题上，假如我们只是为了静态资源的同步，通过`CDN`来解决全球跨地域访问的问题，那么实际上并不是一定需要完全的`SSG`来解决问题。将`CSR`完全转变为`SSR`毕竟是一件改造范围比较大的事情，而我们的目标仅仅是一处生产、多处消费，因此我们可以转过来想一想实际上`JSON`文件也是属于静态资源的一种类型，我们可以直接在前端发起请求将`JSON`文件作为静态资源请求到浏览器并且借助`SDK`渲染即可，至于一些交互行为例如点赞等功能的速度问题我们也是可以接受的，文档站最的主要行为还是阅读文档。此外对于`md`文件我们同样可以如此处理，例如`docsify`就是通过动态请求，但是同样的对于搜索引擎来说这些需要执行`Js`来动态请求的内容并没有那么容易抓取，所以如果想比较好地实现这部分能力还是需要不断优化迭代。

## 基本原理
通常当我们使用`React`进行客户端渲染`CSR - Client Side Render`时，只需要在入口的`index.html`文件中置入`<div id="root"></div>`的独立`DOM`节点，然后在引入的`xxx.js`文件中通过`ReactDOM.render`方法将`React`组件渲染到这个`DOM`节点上即可。



MarkDown MDX


## 组件编译



## 双端渲染

MiniCssExtractPlugin

## 每日一题

```
https://github.com/WindrunnerMax/EveryDay
```

## 参考

```
https://www.sanity.io/ssr-vs-ssg-guide
https://www.theanshuman.dev/articles/what-the-heck-is-ssg-static-site-generation-explained-with-nextjs-5cja
```
